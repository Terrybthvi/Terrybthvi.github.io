<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Android源码分析——ViewGroup的事件分发机制</title>
    <link href="/android/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%94ViewGroup%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/"/>
    <url>/android/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%94ViewGroup%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<p><img src="/android/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%94ViewGroup%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/img1.png" alt="head"><br>通过前一篇博客<a href="../Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%94View%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/">View的事件分发机制，从dispatchTouchEvent说起（一）</a>的介绍相信大家对 Android View 事件的分发机制有了很深的理解。我们知道 Android 中 View 是存在于 Activity。 今天我们继续学习 Activity 到 ViewGroup 的事件分发机制。</p><h2 id="一、Activity-分发到-ViewGroup"><a href="#一、Activity-分发到-ViewGroup" class="headerlink" title="一、Activity 分发到 ViewGroup"></a>一、Activity 分发到 ViewGroup</h2><p>当我们手指触摸到屏幕时，最先接收到事件的肯定是<code>Activity</code>,首先调用的是<code>Activity</code>的<code>dispatchTouchEvent(event)</code>,那么我们下面先来看它的源码：</p><h3 id="1、dispatchTouchEvent-event"><a href="#1、dispatchTouchEvent-event" class="headerlink" title="1、dispatchTouchEvent(event)"></a>1、dispatchTouchEvent(event)</h3><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">dispatchTouchEvent</span><span class="hljs-params">(MotionEvent ev)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (ev.getAction() == MotionEvent.ACTION_DOWN) &#123;<br>            onUserInteraction();<br>        &#125;<br>        <span class="hljs-keyword">if</span> (getWindow().superDispatchTouchEvent(ev)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">return</span> <span class="hljs-title">onTouchEvent</span><span class="hljs-params">(ev)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里我们看到首先它判断了是不是 DOWN 事件，如果是的话调用了<code>onUserInteraction()</code>这个方法我们看到在<code>Activity</code>源码中是空的，它可以让子类去实现。我们这里不需要多做关注。</p><p>下面我们发现这里它继续调用了<code>getWindow().superDispatchTouchEvent(ev)</code>,这里我们后面再讲。我们看到如果前面返回时<code>false</code>的话，后面调用了<code>Activity</code>的<code>onTouchEvent(ev)</code>。</p><p>那么我们继续看<code>getWindow().superDispatchTouchEvent(ev)</code>,这里我们之前文章提到过，<code>getWindow()</code>返回的是 PhoneWindow 对象，那么我们继续看<code>PhoneWindow</code>,我们会发现它调用了<code>mDecor.superDispatchTouchEvent(event)</code>,也就是执行到 DecorView 的<code>superDispatchTouchEvent(event)</code>。我们继续追踪发现，最终掉的是 ViewGroup 的 <code>diapatchTouchEvent(event)</code>方法。</p><p>那我们这里先总结下<code>dispatchTouchEvent</code>：<br><strong>Activity&#x3D;&#x3D;&gt;PhoneWindow&#x3D;&#x3D;&gt;DecorView&#x3D;&#x3D;&gt;ViewGroup</strong></p><h3 id="2、onTouchEvent-event"><a href="#2、onTouchEvent-event" class="headerlink" title="2、onTouchEvent(event)"></a>2、onTouchEvent(event)</h3><p>上面的具体到 ViewGroup 我们后面再看，这里我们还是回到之前的如果返回<code>false</code>那么就需要调用<code>Activity.onTouchEvent(ev)</code>，那么它的源码如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> boolean <span class="hljs-title">onTouchEvent</span>(<span class="hljs-params">MotionEvent <span class="hljs-keyword">event</span></span>)</span> &#123;<br>      <span class="hljs-keyword">if</span> (mWindow.shouldCloseOnTouch(<span class="hljs-keyword">this</span>, <span class="hljs-keyword">event</span>)) &#123;<br>          finish();<br>          <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>      &#125;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br></code></pre></td></tr></table></figure><p>这里只是判断了点击事件的边界条件，如果在边界内就直接返回了<code>false</code>，否则<code>finish</code>当前 Activity。</p><h2 id="二、ViewGroup-的分发"><a href="#二、ViewGroup-的分发" class="headerlink" title="二、ViewGroup 的分发"></a>二、ViewGroup 的分发</h2><p>我们上面看到<code>Activity.dispatchTouchEvent(ev)</code>最终调用到<code>ViewGroup.diapstchTouchEvent(ev)</code>那么下面我们继续看下它的源码：</p><h3 id="1、ViewGroup-dispatchTouchEvent-ev"><a href="#1、ViewGroup-dispatchTouchEvent-ev" class="headerlink" title="1、ViewGroup.dispatchTouchEvent(ev)"></a>1、ViewGroup.dispatchTouchEvent(ev)</h3><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">@Override<br>  <span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span>ean dispatchTouchEvent(MotionEvent ev) &#123;<br>  <span class="hljs-comment">/*****************省略部分非核心代码***********************/</span><br>      <span class="hljs-comment">//标记事件是否被处理</span><br>      <span class="hljs-built_in">bool</span>ean handled = <span class="hljs-literal">false</span>;<br>      <span class="hljs-comment">//判断当前窗口是不是模糊窗口如果是则拦截掉，不是则继续分发</span><br>      <span class="hljs-keyword">if</span> (onFilterTouchEventForSecurity(ev)) &#123;<br>          <span class="hljs-keyword">final</span> <span class="hljs-built_in">int</span> action = ev.getAction();<br>          <span class="hljs-keyword">final</span> <span class="hljs-built_in">int</span> actionMasked = action &amp; MotionEvent.ACTION_MASK;<br><br>          <span class="hljs-comment">// 初始化DOWN事件</span><br>          <span class="hljs-keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN) &#123;<br>              cancelAndClearTouchTargets(ev);<br>              resetTouchState();<br>          &#125;<br><br>          <span class="hljs-comment">// 检查是否拦截该事件</span><br>          <span class="hljs-keyword">final</span> <span class="hljs-built_in">bool</span>ean <span class="hljs-built_in">int</span>ercepted;<br>          <span class="hljs-keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN<br>                  || mFirstTouchTarget != <span class="hljs-literal">null</span>) &#123;<br>                  <span class="hljs-comment">//判断是否可以被拦截</span><br>              <span class="hljs-keyword">final</span> <span class="hljs-built_in">bool</span>ean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != <span class="hljs-number">0</span>;<br>              <span class="hljs-keyword">if</span> (!disallowIntercept) &#123;<br>                  <span class="hljs-built_in">int</span>ercepted = onInterceptTouchEvent(ev);<span class="hljs-comment">//判断是否拦截该事件</span><br>                  ev.setAction(action); <span class="hljs-comment">// restore action in case it was changed</span><br>              &#125; <span class="hljs-keyword">else</span> &#123;<br>                  <span class="hljs-built_in">int</span>ercepted = <span class="hljs-literal">false</span>;<br>              &#125;<br>          &#125; <span class="hljs-keyword">else</span> &#123;<br>              <span class="hljs-built_in">int</span>ercepted = <span class="hljs-literal">true</span>;<br>          &#125;<br>           <span class="hljs-comment">/*****************省略部分非核心代码***********************/</span><br>          <span class="hljs-comment">//检查是否取消</span><br>          <span class="hljs-keyword">final</span> <span class="hljs-built_in">bool</span>ean canceled = resetCancelNextUpFlag(<span class="hljs-keyword">this</span>)<br>                  || actionMasked == MotionEvent.ACTION_CANCEL;<br><br>          <span class="hljs-comment">// Update list of touch targets for pointer down, if needed.</span><br>          <span class="hljs-keyword">final</span> <span class="hljs-built_in">bool</span>ean split = (mGroupFlags &amp; FLAG_SPLIT_MOTION_EVENTS) != <span class="hljs-number">0</span>;<br>          TouchTarget newTouchTarget = <span class="hljs-literal">null</span>;<br>          <span class="hljs-built_in">bool</span>ean alreadyDispatchedToNewTouchTarget = <span class="hljs-literal">false</span>;<br>          <span class="hljs-comment">//如果不拦截并且不取消则继续执行</span><br>          <span class="hljs-keyword">if</span> (!canceled &amp;&amp; !<span class="hljs-built_in">int</span>ercepted) &#123;<br>            <br>              View childWithAccessibilityFocus = ev.isTargetAccessibilityFocus()<br>                      ? findChildWithAccessibilityFocus() : <span class="hljs-literal">null</span>;<br><br>              <span class="hljs-keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN<br>                      || (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN)<br>                      || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123;<br>                 <span class="hljs-comment">/*****************省略部分非核心代码***********************/</span><br>                  <span class="hljs-keyword">final</span> <span class="hljs-built_in">int</span> childrenCount = mChildrenCount;<br>                  <span class="hljs-comment">//newTouchTarget触摸目标链表里面存储有子View</span><br>                  <span class="hljs-keyword">if</span> (newTouchTarget == <span class="hljs-literal">null</span> &amp;&amp; childrenCount != <span class="hljs-number">0</span>) &#123;<br>                     <span class="hljs-comment">/*****************省略部分非核心代码***********************/</span><br>                      <span class="hljs-keyword">final</span> View[] children = mChildren;<br>                      <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = childrenCount - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>                          <span class="hljs-keyword">final</span> <span class="hljs-built_in">int</span> childIndex = getAndVerifyPreorderedIndex(<br>                                  childrenCount, i, customOrder);<br>                          <span class="hljs-keyword">final</span> View child = getAndVerifyPreorderedView(<br>                                  preorderedList, children, childIndex);<br><br>                         <span class="hljs-comment">/*****************省略部分非核心代码***********************/</span><br>                         <span class="hljs-comment">//将当前子View添加到newTouchTarget</span><br>                          newTouchTarget = getTouchTarget(child);<br>                         <span class="hljs-comment">/*****************省略部分非核心代码***********************/</span><br>                         <span class="hljs-comment">//这里去分发TouchEvent </span><br>                          <span class="hljs-keyword">if</span> (dispatchTransformedTouchEvent(ev, <span class="hljs-literal">false</span>, child, idBitsToAssign)) &#123;<br>                          <br>                              <span class="hljs-comment">/*****************省略部分非核心代码***********************/</span><br>                                <br>                          &#125;<br>                          <br>           <span class="hljs-comment">/*****************省略部分非核心代码***********************/</span><br>        <br>      <span class="hljs-keyword">return</span> handled;<br>  &#125;<br><br></code></pre></td></tr></table></figure><p>这个方法可以说是非常的多，看着就令人头大。</p><p>这里我们主要看核心代码，以下重要的代码我再里面都添加了注释。非核心代码我们这里略过。我们这里注意以下几点：</p><ol><li><font color="red"><strong>handled：</strong></font> 这个变量是标记触摸事件是否被处理的，默认是<code>false</code>代表未被消耗。</li><li><font color="red"><strong>onFilterTouchEventForSecurity(ev)：</strong></font>  这个方法我们看到是一个非常重要的方法，后面几乎所有的代码都在这个方法返回<code>true</code>之后才执行。那么这个方法是干啥的呢？它其实是判断当前窗口是否是模糊窗口？如果是的话则返回<code>false</code>,此时将不会在将事件分发给子 View.</li><li><font color="red"> <strong>intercepted:</strong></font> 标记当前父布局要不要拦截当前事件,一般都是取<code>onInterceptTouchEvent(ev)</code>的方法。</li><li><font color="red"> <strong>onInterceptTouchEvent(ev):</strong></font>判断当前 ViewGroup 是否拦截当前事件，一般返回<code>flase</code>不拦截。我们可以在子类重写该方法。</li><li><font color="red"><strong>cancled：</strong></font> 这个变量就是带判断当前手势是不是被取消。如果<code>cancled</code>和<code>intercepted</code>都是<code>false</code>才会去执行后面的分发。</li><li><font color="red"><strong>newTouchTarget：</strong></font>这是一个单向链表，里面存储的是触摸目标的 View 。后面调用<code>getTouchTarget(child)</code>将子 View 的触摸目标添加到 newTouchTarget 。</li><li><font color="red"><strong>dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)：</strong></font> 这个方法就是去将触摸事件分发给对应子 View,下面我们就来看下这个方法。</li></ol><h4 id="I、ViewGroup-dispatchTransformedTouchEvent"><a href="#I、ViewGroup-dispatchTransformedTouchEvent" class="headerlink" title="I、ViewGroup.dispatchTransformedTouchEvent"></a>I、ViewGroup.dispatchTransformedTouchEvent</h4><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs verilog">private boolean dispatchTransformedTouchEvent(MotionEvent <span class="hljs-keyword">event</span>, boolean cancel,<br>        View child, <span class="hljs-keyword">int</span> desiredPointerIdBits) &#123;<br>    <span class="hljs-keyword">final</span> boolean handled;<br><br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> oldAction = <span class="hljs-keyword">event</span><span class="hljs-variable">.getAction</span>();<br>    <span class="hljs-comment">//判断是否是取消</span><br>    <span class="hljs-keyword">if</span> (cancel || oldAction == MotionEvent<span class="hljs-variable">.ACTION_CANCEL</span>) &#123;<br>        <span class="hljs-keyword">event</span><span class="hljs-variable">.setAction</span>(MotionEvent<span class="hljs-variable">.ACTION_CANCEL</span>);<br>        <span class="hljs-keyword">if</span> (child == <span class="hljs-literal">null</span>) &#123;<br>            handled = <span class="hljs-keyword">super</span><span class="hljs-variable">.dispatchTouchEvent</span>(<span class="hljs-keyword">event</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            handled = child<span class="hljs-variable">.dispatchTouchEvent</span>(<span class="hljs-keyword">event</span>);<br>        &#125;<br>        <span class="hljs-keyword">event</span><span class="hljs-variable">.setAction</span>(oldAction);<br>        <span class="hljs-keyword">return</span> handled;<br>    &#125;<br><br>  <span class="hljs-comment">/*****************省略部分非核心代码***********************/</span><br>    <span class="hljs-keyword">final</span> MotionEvent transformedEvent;<br>    <span class="hljs-keyword">if</span> (newPointerIdBits == oldPointerIdBits) &#123;<br>        <span class="hljs-keyword">if</span> (child == <span class="hljs-literal">null</span> || child<span class="hljs-variable">.hasIdentityMatrix</span>()) &#123;<br>            <span class="hljs-keyword">if</span> (child == <span class="hljs-literal">null</span>) &#123;<br>                handled = <span class="hljs-keyword">super</span><span class="hljs-variable">.dispatchTouchEvent</span>(<span class="hljs-keyword">event</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">final</span> float offsetX = mScrollX - child<span class="hljs-variable">.mLeft</span>;<br>                <span class="hljs-keyword">final</span> float offsetY = mScrollY - child<span class="hljs-variable">.mTop</span>;<br>                <span class="hljs-keyword">event</span><span class="hljs-variable">.offsetLocation</span>(offsetX, offsetY);<br>                <br>                <span class="hljs-comment">//调用子 View 的dispatchTouchEvent(event)</span><br>                handled = child<span class="hljs-variable">.dispatchTouchEvent</span>(<span class="hljs-keyword">event</span>);<br><br>     <span class="hljs-comment">/*****************省略部分非核心代码***********************/</span><br> <br>    <span class="hljs-keyword">return</span> handled;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个方法的代码也不少我们来看看核心代码，首先前面判断当前事件是否是取消事件。如果是的话则执行子 View 的<code>dispatchTouchEvent</code>。 后面我们看到最终执行到<code>handled = child.dispatchTouchEvent(event);</code>来返回<code>handled</code>。到这里我们就发现最终这里调用的是 View 的 <code>dispatchTouchEvent(event)</code>。所以这里我们可以用下面的伪代码来总结一下 ViewGroup 的事件分发机制。</p><h3 id="2、伪代码总结ViewGroup的事件分发"><a href="#2、伪代码总结ViewGroup的事件分发" class="headerlink" title="2、伪代码总结ViewGroup的事件分发"></a>2、伪代码总结ViewGroup的事件分发</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-built_in">boolean</span> <span class="hljs-title function_">dispatchTouchEvent</span>(<span class="hljs-params">MotionEvent ev</span>)&#123;<br>    <span class="hljs-built_in">boolean</span> concume = <span class="hljs-literal">false</span>;<br>    <span class="hljs-comment">//调用onInterceptTouchEvent判断是否拦截</span><br>    <span class="hljs-keyword">if</span>(<span class="hljs-title function_">onInterceptTouchEvent</span>(ev))&#123;<br>      <span class="hljs-comment">//如果拦截则调用自己的onTouchEvent(ev)消耗</span><br>      consume = <span class="hljs-title function_">onTouchEvent</span>(ev);<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-comment">//如果不拦截，则将事件分发给子View</span><br>        consume = child.<span class="hljs-title function_">dispatchTouchEvent</span>(ev);<br>    &#125;<br>    <span class="hljs-keyword">return</span> consume;<br>&#125;<br></code></pre></td></tr></table></figure><p>总体来说就是首先判断 ViewGroup 自己拦截不拦截，如果拦截则调用自己的<code>onTouchEvent(ev)</code>,如果不拦截则调用子 View 的<code>dispatchTouchEvent(event)</code>。</p><h2 id="三、总结测试"><a href="#三、总结测试" class="headerlink" title="三、总结测试"></a>三、总结测试</h2><p>我们还是写一个简单的项目来测试一下，一个 Activity,一个ViewGroup ，一个View。我们分别重写我们上述提到的方法。<br>写之前我们先思考下面两个问题： <font color="green"></font></p><ol><li>当所有View都不消耗该事件的时候，事件如何传递？</li><li>子View不处理事件时，UP 事件是跟 DOWN 事件一样传递的吗？</li><li>子 View 消耗完事件，ViewGroup 的 <code>onTouchEvent</code>还会执行吗？</li></ol><h4 id="MainActivity-java"><a href="#MainActivity-java" class="headerlink" title="MainActivity.java"></a>MainActivity.java</h4><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Activity</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState);<br>        setContentView(<span class="hljs-keyword">new</span> CustomLayout(<span class="hljs-keyword">this</span>));<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">onTouchEvent</span><span class="hljs-params">(MotionEvent event)</span> </span>&#123;<br>        Log.e(<span class="hljs-string">&quot;TAG_紫雾凌寒_MainActivity&quot;</span>,<span class="hljs-string">&quot;===onTouchEvent====&quot;</span>+event.getAction());<br>        <span class="hljs-function"><span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.<span class="hljs-title">onTouchEvent</span><span class="hljs-params">(event)</span></span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">dispatchTouchEvent</span><span class="hljs-params">(MotionEvent ev)</span> </span>&#123;<br>        Log.e(<span class="hljs-string">&quot;TAG_紫雾凌寒_MainActivity&quot;</span>,<span class="hljs-string">&quot;===dispatchTouchEvent====&quot;</span>+ev.getAction());<br>        <span class="hljs-function"><span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.<span class="hljs-title">dispatchTouchEvent</span><span class="hljs-params">(ev)</span></span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="CustomLayout-java"><a href="#CustomLayout-java" class="headerlink" title="CustomLayout.java"></a>CustomLayout.java</h4><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomLayout</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">LinearLayout</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CustomLayout</span><span class="hljs-params">(Context context)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(context);<br>        addView(<span class="hljs-keyword">new</span> CustomView(context));<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">onInterceptTouchEvent</span><span class="hljs-params">(MotionEvent ev)</span> </span>&#123;<br>        Log.e(<span class="hljs-string">&quot;TAG_紫雾凌寒_CustomLayout&quot;</span>,<span class="hljs-string">&quot;===onInterceptTouchEvent====&quot;</span>+ev.getAction());<br>        <span class="hljs-function"><span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.<span class="hljs-title">onInterceptTouchEvent</span><span class="hljs-params">(ev)</span></span>;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">dispatchTouchEvent</span><span class="hljs-params">(MotionEvent ev)</span></span>&#123;<br>        Log.e(<span class="hljs-string">&quot;TAG_紫雾凌寒_CustomLayout&quot;</span>,<span class="hljs-string">&quot;===dispatchTouchEvent====&quot;</span>+ev.getAction());<br>        <span class="hljs-function"><span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.<span class="hljs-title">dispatchTouchEvent</span><span class="hljs-params">(ev)</span></span>;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">onTouchEvent</span><span class="hljs-params">(MotionEvent event)</span></span>&#123;<br>        Log.e(<span class="hljs-string">&quot;TAG_紫雾凌寒_CustomLayout&quot;</span>,<span class="hljs-string">&quot;===onTouchEvent====&quot;</span>+event.getAction());<br>        <span class="hljs-function"><span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.<span class="hljs-title">onTouchEvent</span><span class="hljs-params">(event)</span></span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="CustomView-java"><a href="#CustomView-java" class="headerlink" title="CustomView.java"></a>CustomView.java</h4><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomView</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">View</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">dispatchTouchEvent</span><span class="hljs-params">(MotionEvent event)</span> </span>&#123;<br>        Log.e(<span class="hljs-string">&quot;TAG_紫雾凌寒_CustomView__&quot;</span>,<span class="hljs-string">&quot;===dispatchTouchEvent====&quot;</span>+event.getAction());<br>        <span class="hljs-function"><span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.<span class="hljs-title">dispatchTouchEvent</span><span class="hljs-params">(event)</span></span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onDraw</span><span class="hljs-params">(Canvas canvas)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>.onDraw(canvas);<br>        Paint paint = <span class="hljs-keyword">new</span> Paint();<br>        paint.setColor(Color.BLUE);<br>        paint.setStrokeWidth(<span class="hljs-number">5</span>f);<br>        paint.setStyle(Paint.Style.FILL);<br>        canvas.drawCircle(<span class="hljs-number">300</span>,<span class="hljs-number">300</span>,<span class="hljs-number">280</span>,paint);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">onTouchEvent</span><span class="hljs-params">(MotionEvent event)</span> </span>&#123;<br>        Log.e(<span class="hljs-string">&quot;TAG_紫雾凌寒_CustomView__&quot;</span>,<span class="hljs-string">&quot;===onTouchEvent====&quot;</span>+event.getAction());<br>        <span class="hljs-function"><span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.<span class="hljs-title">onTouchEvent</span><span class="hljs-params">(event)</span></span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CustomView</span><span class="hljs-params">(Context context)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(context);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1、子View也不处理触摸事件"><a href="#1、子View也不处理触摸事件" class="headerlink" title="1、子View也不处理触摸事件"></a>1、子View也不处理触摸事件</h4><p>我们回到之前我们的问题，当子 View 也不处理触摸事件的时候，那么触摸事件该如何传递？<br>对于这样的问题我们模拟一下，上面的代码就是子View对事件没有消耗，我们点击自定义 View 的区域，我们看到日志如下所示：<br><img src="/android/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%94ViewGroup%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/img2.png" alt="logcat"><br>我们通过日志看到，<font color="red">当子View不处理时，我们看到事件的传递是会返回到 Activity 执行 Activity 的 onTouchEvent(ev).</font></p><p>同样我们可以看到，<font color="red">当执行完 DOWN 事件后，UP 事件只在 Activity 层，并没有传递至 ViewGroup 和 View。</font></p><h4 id="2、子View处理触摸事件"><a href="#2、子View处理触摸事件" class="headerlink" title="2、子View处理触摸事件"></a>2、子View处理触摸事件</h4><p>那么我们让子View处理触摸事件，也就是<code>View.onTouchEvent(ev)</code>返回<code>true</code>.我们再来看下日志：<br><img src="/android/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%94ViewGroup%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/img3.png" alt="logcat"><br>这里我们看到当View如果处理触摸事件时，DOWN 和 UP事件的传递是一样的。消耗完之后就不会再返回上一层了。我们看到子 View 处理完事件后，ViewGroup 的 onTouchEvent 没再执行了。</p><h4 id="3、父布局拦截事件"><a href="#3、父布局拦截事件" class="headerlink" title="3、父布局拦截事件"></a>3、父布局拦截事件</h4><p>当我们让 ViewGroup 拦截触摸事件时我们看看日志是不是跟我们前面分析的一样？<br><img src="/android/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%94ViewGroup%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/img4.png" alt="logcat"><br>我们看到这里跟我们分析的一样，当 ViewGroup 拦截后，就不会传递到 View 。</p><h4 id="4、总结"><a href="#4、总结" class="headerlink" title="4、总结"></a>4、总结</h4><p>我们回顾一下本文我们主要讲的 Activity 的触摸事件的分发机制：<font color="red"><strong>手指按下屏幕&#x3D;&#x3D;&gt;Activity&#x3D;&#x3D;&gt;PhoneWindow&#x3D;&#x3D;&gt;DecorView&#x3D;&#x3D;&gt;ViewGroup&#x3D;&#x3D;View</strong></font>。下面我们还是通过流程图来总结一下它的传递机制：<br><img src="/android/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%94ViewGroup%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/img5.png" alt="Activity事件的分发"></p><blockquote><p>欢迎在评论区留下你的观点大家一起交流，一起成长。如果今天的这篇文章对你在工作和生活有所帮助，欢迎<font color="green"><strong>转发</strong></font>分享给更多人。<br></p><p>同时欢迎大家<font color="green"><strong>扫描下方的二维码关注我的公众号</strong></font>大家一起学习交流 Android、HarmonyOS等知识。从这里出发我们一起讨论，一起交流，一起提升。</p></blockquote><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9Wek56NExhdFFNM2czcEI2aFVKODRYRmwxTnFPWlM1ZGJ1NWlhbzJGSzd1TFhqOGdlMDlha2RNWXhpYTZyZFdXbDRENHZGaWEyaWFVQjZpYWU2aWFxUjY5dlM0Zy82NDA?x-oss-process=image/format,png" alt="我的公众号"></p><p><strong>往期推荐</strong></p><ul><li><a href="../Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%94View%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6">View的事件分发机制，从dispatchTouchEvent说起（一）</a></li><li><a href="../Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%94View%E6%98%AF%E5%A6%82%E4%BD%95%E8%A2%AB%E6%B7%BB%E5%8A%A0%E5%88%B0%E5%B1%8F%E5%B9%95%E7%9A%84">Android源码分析——View是如何被添加到屏幕的？</a></li><li><a href="../Android%E7%83%AD%E4%BF%AE%E5%A4%8D%E2%80%94%E2%80%94%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E5%AE%9E%E7%8E%B0AndFix%E7%83%AD%E4%BF%AE%E5%A4%8D">Android热修复——深入剖析AndFix热修复及自己动手实现</a></li><li><a href="https://blog.csdn.net/u013132758/article/details/89181005">深入理解HashMap原理(一)——HashMap源码解析(JDK 1.8)</a></li><li><a href="https://bthvi-leiqi.blog.csdn.net/article/details/89354198">深入理解HashMap原理(二)——手写HashMap</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>源码解析</tag>
      
      <tag>View</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android源码分析——View的事件分发机制</title>
    <link href="/android/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%94View%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/"/>
    <url>/android/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%94View%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<p><img src="/android/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%94View%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/img1.png" alt="head"><br>事件分发机制是android中的核心知识点和难点。相信很多人也和我一样对于这点感到非常困惑。我看了很多篇博客和书面资料。今天我们就聊聊事件的分发机制。</p><h2 id="一、点击事件的传递规则"><a href="#一、点击事件的传递规则" class="headerlink" title="一、点击事件的传递规则"></a>一、点击事件的传递规则</h2><h3 id="1、什么是点击事件（MotionEvent）"><a href="#1、什么是点击事件（MotionEvent）" class="headerlink" title="1、什么是点击事件（MotionEvent）"></a>1、什么是点击事件（MotionEvent）</h3><p>在了解点击事件的传递规则之前，我们首先要弄明白什么事点击事件（MotionEvent），所谓MotionEvent是指手指接触屏幕后所产生的一系列事件。</p><p><strong>ACTION_DOWN————手指刚接触屏幕。</strong><br><strong>ACTION_MOVE————手指在屏幕上移动。</strong><br><strong>ACYION_UP————手指从屏幕上松开的一瞬间。</strong></p><h3 id="2、点击事件分发过程"><a href="#2、点击事件分发过程" class="headerlink" title="2、点击事件分发过程"></a>2、点击事件分发过程</h3><p>点击事件的分发过程就是<code>MotionEvent</code>的分发过程，该过程主要由以下三个函数来完成：</p><p><code>public boolean dispatchTouchEvent(MotionEvent ev)</code></p><p><strong>功能</strong>：用来进行事件的分发</p><p><code>public boolean onInterceptTouchEvent(MotionEvent ev)</code></p><p><strong>功能</strong>：用来判断是否拦截某个事件。</p><p><code>public boolean onTouchEvent(MotionEvent ev)</code></p><p><strong>功能</strong>：处理点击事件，在<code>dispatchTouchEvent</code>中调用。返回结果表示是否消耗当前点击事件。</p><p>先不急我们从最简单的<code>OnClickListener</code>来看，<code>OnClickListener</code>的优先级最低，处于事件传递的尾端。</p><p>我们首先简单创建一个Android 项目，只有一个 Activity ，并且 Activity 中有一个按钮。如果我们想要给这个按钮注册一个点击事件，只需要调用如下的代码：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs typescript">button.<span class="hljs-title function_">setOnClickListener</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">OnClickListener</span>() &#123;  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">onClick</span>(<span class="hljs-params">View v</span>) &#123;  <br>        <span class="hljs-title class_">Log</span>.<span class="hljs-title function_">e</span>(<span class="hljs-string">&quot;TAG_紫雾凌寒&quot;</span>,<span class="hljs-string">&quot;执行了onClick&quot;</span>);<br>    &#125;  <br>&#125;); <br></code></pre></td></tr></table></figure><p>这样在<code>onClick()</code>方法里面写我们需要处理的业务逻辑，就可以在按钮被点击的时候执行。再如果想给这个按钮再添加一个 touch 事件，只需要调用如下所示的代码：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript">button.<span class="hljs-title function_">setOnTouchListener</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">OnTouchListener</span>() &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">boolean</span> <span class="hljs-title function_">onTouch</span>(<span class="hljs-params">View v, MotionEvent event</span>) &#123;<br>    <span class="hljs-title class_">Log</span>.<span class="hljs-title function_">e</span>(<span class="hljs-string">&quot;TAG_紫雾凌寒&quot;</span>,<span class="hljs-string">&quot;执行了onTouch==Action=&quot;</span>+event.<span class="hljs-title function_">getAction</span>());<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>我们仅仅凭 Touch[触摸] 和 Click[点击] 就能够猜想到<code>onTouch()</code>方法里能做的事情比<code>onClick()</code>要多一些，比如判断手指按下、抬起、移动等事件。那么我同时给 button 两个事件都注册了，哪一个会先执行呢？我们用事实说话，运行程序点击按钮，我们会发现打印结果如下：<br><img src="/android/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%94View%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/img2.png" alt="在这里插入图片描述"><br>这里我们可以看到，<code>onTouch()</code>是优先于<code>onClick()</code>执行的，并且根据日志可以看到<code>onTouch()</code>执行了两次，一次是 ACTION_DOWN ，一次是 ACTION_UP (当你手指按下屏幕并在屏幕上滑动时，还会有多次 ACTION_MOVE 的执行)。因此事件传递的顺序是先经过<code>onTouch()</code>，再传递到<code>onClick()</code>。</p><p>有些同学可能已经注意到，<code>onTouch()</code>方法是有返回值的，这里我们返回的是 false 。如果我们尝试把<code>onTouch()</code>方法里的返回值改成 true ，再运行一次，结果如下：<br><img src="/android/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%94View%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/img3.png" alt="在这里插入图片描述"></p><p>我们发现，<code>onClick()</code>方法不再执行了！那为什么会这样呢？具体的原因看完这篇文章大家就明白了，这里我们可以先理解成<code>onTouch()</code>方法返回 true 就认为这个事件被<code>onTouch()</code>消费了，因而不会再继续向下传递。</p><p>如果读到这里，以上所有的知识点你都清楚，那么说明你对 Android 事件传递算是入门了。<br>下面我们继续接着往下看，我们通过源码的角度来分析以下。</p><h3 id="3、点击事件递"><a href="#3、点击事件递" class="headerlink" title="3、点击事件递"></a>3、点击事件递</h3><p>首先我们要知道，当我们手指触摸屏幕上的控件后，接下来肯定会调用它的<code>dispatchTouchEvent</code>方法。我们根据下面一张图来分析<br><img src="/android/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%94View%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/img4.png" alt="在这里插入图片描述"><br>当我们手指点击屏幕上的 button 时，就会去调用 button 的<code>dispatchTouchEvent</code>方法，这时候会发现button 里面没有这个方法，那么它就会继续向上查找它的父类 TextView 的<code>dispatchTouchEvent</code>方法，如果没有还是继续向上查找，直到找到 View 中会发现这里有<code>dispatchTouchEvent</code>方法。</p><h2 id="二、源码分析"><a href="#二、源码分析" class="headerlink" title="二、源码分析"></a>二、源码分析</h2><p>下面我们根据源码来看看，事件究竟是如何传递的？首先我们还是来看<code>dispatchTouchEvent</code>方法。</p><h3 id="1-View-dispatchEvent-event"><a href="#1-View-dispatchEvent-event" class="headerlink" title="1.View.dispatchEvent(event)"></a>1.View.dispatchEvent(event)</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> boolean <span class="hljs-title">dispatchTouchEvent</span>(<span class="hljs-params">MotionEvent <span class="hljs-keyword">event</span></span>)</span> &#123;<br>  <span class="hljs-comment">/***********省略部分代码******************/</span><br>    boolean result = <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-keyword">if</span> (mInputEventConsistencyVerifier != <span class="hljs-literal">null</span>) &#123;<br>        mInputEventConsistencyVerifier.onTouchEvent(<span class="hljs-keyword">event</span>, <span class="hljs-number">0</span>);<br>    &#125;<br><br>    final <span class="hljs-built_in">int</span> actionMasked = <span class="hljs-keyword">event</span>.getActionMasked();<br>    <span class="hljs-keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN) &#123;<br>        <span class="hljs-comment">// 如果是Down停止滚动</span><br>        stopNestedScroll();<br>    &#125;<br>    <span class="hljs-comment">//重要的代码就是这里    </span><br>    <span class="hljs-keyword">if</span> (onFilterTouchEventForSecurity(<span class="hljs-keyword">event</span>)) &#123;<br>        <span class="hljs-keyword">if</span> ((mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; handleScrollBarDragging(<span class="hljs-keyword">event</span>)) &#123;<br>            result = <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-comment">//noinspection SimplifiableIfStatement</span><br>        ListenerInfo li = mListenerInfo;<br>        <span class="hljs-keyword">if</span> (li != <span class="hljs-literal">null</span> &amp;&amp; li.mOnTouchListener != <span class="hljs-literal">null</span><br>                &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED<br>                &amp;&amp; li.mOnTouchListener.onTouch(<span class="hljs-keyword">this</span>, <span class="hljs-keyword">event</span>)) &#123;<br>            result = <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!result &amp;&amp; onTouchEvent(<span class="hljs-keyword">event</span>)) &#123;<br>            result = <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>  <span class="hljs-comment">/***********省略部分代码******************/</span><br><br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里我们首先看到它定义了一个变量 <code>result</code>,它的默认值是false,仅接着就去调用了<code>onFilterTouchEventForSecurity(event)</code>这个方法，这个方法主要作用就是判断该触摸事件要不要分发，我们下面来看下这个方法。</p><h4 id="onFilterTouchEventForSecurity-event"><a href="#onFilterTouchEventForSecurity-event" class="headerlink" title="onFilterTouchEventForSecurity(event)"></a>onFilterTouchEventForSecurity(event)</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> boolean <span class="hljs-title">onFilterTouchEventForSecurity</span>(<span class="hljs-params">MotionEvent <span class="hljs-keyword">event</span></span>)</span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-comment">// 先检查View有没有设置被遮挡时不处理触摸事件的flag</span><br>        (mViewFlags &amp; FILTER_TOUCHES_WHEN_OBSCURED) != <span class="hljs-number">0</span><br>            <span class="hljs-comment">// 再检查受到该事件的窗口是否被其它窗口遮挡</span><br>            &amp;&amp; (<span class="hljs-keyword">event</span>.getFlags() &amp; MotionEvent.FLAG_WINDOW_IS_OBSCURED) != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// Window is obscured, drop this touch.</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个方法的代码不多几行就是判断当前 View 有没有被遮挡，还有 View 对应的窗口有没有被遮挡。</p><blockquote><p>**Tips:**既然判断事件要不要被分发，有一条是根据<code>mViewFlags</code>标志的，那我们完全可以通过设置或是清楚<code>FILTER_TOUCHES_WHEN_OBSCURED</code>标志位，这样就可以控制触摸事件在弹出窗口后，后续的事件能否继续处理。</p></blockquote><p>看完<code>onFilterTouchEventForSecurity</code>方法我们继续回到前面的<code>dispatchTouchEvent</code>中。我们看到如果前面是<code>true</code>，那么接下来会判断 view 的<code>mOnTouchListener</code>是不是空，并且这个View是不是可以点击的，如果可以点击并且<code>mOnTouchListener</code>不为空的话，就会继续调用<code>mOnTouchListener.onTouch(this.event)</code>,它如果也是 true 的话，就给<code>result</code>赋值为 true ,后面就不再调用view的点击事件了。这就是我们前面说的<code>onTouch()</code>的方法改为 true 后就不会再执行<code>onClik</code>的原因。</p><blockquote><p>**Tips:**也就是说我们调用<code>setOnTouchListener</code>设置的 OnTouchListener 的<code>onTouch()</code>优先级比<code>onTouchEvent(event)</code>高。<br>如果前面不满足<code>result</code>为false，那么就会继续调用<code>onTouchEvent(event)</code>方法。</p></blockquote><h3 id="2、View-onTouchEvent-event"><a href="#2、View-onTouchEvent-event" class="headerlink" title="2、View.onTouchEvent(event)"></a>2、View.onTouchEvent(event)</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title">onTouchEvent</span><span class="hljs-params">(MotionEvent event)</span> </span>&#123;<br>       <span class="hljs-keyword">final</span> <span class="hljs-type">float</span> x = event.<span class="hljs-built_in">getX</span>();<br>       <span class="hljs-keyword">final</span> <span class="hljs-type">float</span> y = event.<span class="hljs-built_in">getY</span>();<br>       <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> viewFlags = mViewFlags;<br>       <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> action = event.<span class="hljs-built_in">getAction</span>();<br>       <span class="hljs-comment">//判断View是不是可点击</span><br>       <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> clickable = ((viewFlags &amp; CLICKABLE) == CLICKABLE<br>               || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE)<br>               || (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE;<br><br>       <span class="hljs-comment">/***********省略部分代码******************/</span><br>       <span class="hljs-keyword">if</span> (clickable || (viewFlags &amp; TOOLTIP) == TOOLTIP) &#123;<br>           <span class="hljs-keyword">switch</span> (action) &#123;<br>               <span class="hljs-keyword">case</span> MotionEvent.ACTION_UP:<br>                   mPrivateFlags3 &amp;= ~PFLAG3_FINGER_DOWN;<br>                   <span class="hljs-keyword">if</span> ((viewFlags &amp; TOOLTIP) == TOOLTIP) &#123;<br>                       <span class="hljs-built_in">handleTooltipUp</span>();<br>                   &#125;<br>                   <span class="hljs-comment">/***********省略部分代码******************/</span><br>                           <span class="hljs-comment">// Only perform take click actions if we were in the pressed state</span><br>                           <span class="hljs-keyword">if</span> (!focusTaken) &#123;<br>                               <span class="hljs-comment">// Use a Runnable and post this rather than calling</span><br>                               <span class="hljs-comment">// performClick directly. This lets other visual state</span><br>                               <span class="hljs-comment">// of the view update before click actions start.</span><br>                               <span class="hljs-keyword">if</span> (mPerformClick == null) &#123;<br>                                   mPerformClick = <span class="hljs-keyword">new</span> <span class="hljs-built_in">PerformClick</span>();<br>                               &#125;<br>                               <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">post</span>(mPerformClick)) &#123;<br>                                   <span class="hljs-built_in">performClickInternal</span>();<br>                               &#125;<br>                           &#125;<br>                       &#125;<br><br>                      <span class="hljs-comment">/***********省略部分代码******************/</span><br>                   <span class="hljs-keyword">break</span>;<br><br>               <span class="hljs-keyword">case</span> MotionEvent.ACTION_DOWN:<br>                   <span class="hljs-keyword">if</span> (event.<span class="hljs-built_in">getSource</span>() == InputDevice.SOURCE_TOUCHSCREEN) &#123;<br>                       mPrivateFlags3 |= PFLAG3_FINGER_DOWN;<br>                   &#125;<br>                   mHasPerformedLongPress = <span class="hljs-literal">false</span>;<br><br>                   <span class="hljs-keyword">if</span> (!clickable) &#123;<br>                       <span class="hljs-built_in">checkForLongClick</span>(<span class="hljs-number">0</span>, x, y);<br>                       <span class="hljs-keyword">break</span>;<br>                   &#125;<br><br>                   <span class="hljs-keyword">if</span> (<span class="hljs-built_in">performButtonActionOnTouchDown</span>(event)) &#123;<br>                       <span class="hljs-keyword">break</span>;<br>                   &#125;<br><br>                 <span class="hljs-comment">/***********省略部分代码******************/</span><br>                   <span class="hljs-keyword">break</span>;<br><br>               <span class="hljs-keyword">case</span> MotionEvent.ACTION_CANCEL:<br>                   <span class="hljs-keyword">if</span> (clickable) &#123;<br>                       <span class="hljs-built_in">setPressed</span>(<span class="hljs-literal">false</span>);<br>                   &#125;<br>                   <span class="hljs-built_in">removeTapCallback</span>();<br>                   <span class="hljs-built_in">removeLongPressCallback</span>();<br>                   mInContextButtonPress = <span class="hljs-literal">false</span>;<br>                   mHasPerformedLongPress = <span class="hljs-literal">false</span>;<br>                   mIgnoreNextUpEvent = <span class="hljs-literal">false</span>;<br>                   mPrivateFlags3 &amp;= ~PFLAG3_FINGER_DOWN;<br>                   <span class="hljs-keyword">break</span>;<br><br>               <span class="hljs-keyword">case</span> MotionEvent.ACTION_MOVE:<br>                   <span class="hljs-keyword">if</span> (clickable) &#123;<br>                       <span class="hljs-built_in">drawableHotspotChanged</span>(x, y);<br>                   &#125;<br>                   <span class="hljs-comment">/***********省略部分代码******************/</span><br>                   <span class="hljs-keyword">break</span>;<br>           &#125;<br><br>           <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>       &#125;<br><br>       <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>   &#125;<br></code></pre></td></tr></table></figure><p>我们看到这个方法非常的长，我们注意下面几点就OK。<br>1.<code>clickable</code>判断 View 是不是可点击的。<br>2.如果是的话会根据手势的 ACTION_DOWN,ACTION_UP,ACTION_MOVE,ACTION_CANCEL。来执行不同的代码。<br>3.我们主要看按下手势 ACTION_DOWN 和抬起手势 ACTION_UP。</p><h4 id="I-MotionEvent-ACTION-DOWN"><a href="#I-MotionEvent-ACTION-DOWN" class="headerlink" title="I.MotionEvent.ACTION_DOWN"></a>I.MotionEvent.ACTION_DOWN</h4><p>下面我们首先看 ACTION_DOWN ，如果是不可点击的那么就会执行<code>checkForLongClick(0, x, y)</code>判断是不是长按。</p><h5 id="a-checkForLongClick-0-x-y"><a href="#a-checkForLongClick-0-x-y" class="headerlink" title="a.checkForLongClick(0, x, y)"></a>a.checkForLongClick(0, x, y)</h5><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">checkForLongClick</span><span class="hljs-params">(<span class="hljs-keyword">int</span> delayOffset, <span class="hljs-keyword">float</span> x, <span class="hljs-keyword">float</span> y)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> ((mViewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE || (mViewFlags &amp; TOOLTIP) == TOOLTIP) &#123;<br>            mHasPerformedLongPress = <span class="hljs-keyword">false</span>;<br><br>            <span class="hljs-keyword">if</span> (mPendingCheckForLongPress == <span class="hljs-keyword">null</span>) &#123;<br>                mPendingCheckForLongPress = <span class="hljs-keyword">new</span> CheckForLongPress();<br>            &#125;<br>            mPendingCheckForLongPress.setAnchor(x, y);<br>            mPendingCheckForLongPress.rememberWindowAttachCount();<br>            mPendingCheckForLongPress.rememberPressedState();<br>            postDelayed(mPendingCheckForLongPress,<br>                    ViewConfiguration.getLongPressTimeout() - delayOffset);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>我们看到这里主要是如果是长按的话会，延迟发送消息执行一个Runable-<code>CheckForLongPress</code>,下面我们看下，这个 Runable 的<code>run()</code>方法：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">run</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">if</span> ((mOriginalPressedState == <span class="hljs-title function_">isPressed</span>()) &amp;&amp; (mParent != <span class="hljs-literal">null</span>)<br>            &amp;&amp; mOriginalWindowAttachCount == mWindowAttachCount) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-title function_">performLongClick</span>(mX, mY)) &#123;<br>            mHasPerformedLongPress = <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里我们看到其实就做了一件事调用了<code>(performLongClick(mX, mY)</code>我们继续跟这个方法，发现它最后调用<code>performLongClickInternal</code>执行了长按的操作。这里就不多做深入了。</p><p>我们回到 ACTION_DOWN ，继续往下看，我们会发现紧接着就调用了<code>performButtonActionOnTouchDown(event)</code>,这个方法就是判断是不是鼠标右键，弹出菜单之类的，下面会判断是不是滚动视图之类的。我们这里了解一下就好。</p><h4 id="I-MotionEvent-ACTION-UP"><a href="#I-MotionEvent-ACTION-UP" class="headerlink" title="I.MotionEvent.ACTION_UP"></a>I.MotionEvent.ACTION_UP</h4><p>下面我们看当我们抬起手指的时候，执行了那些操作呢?</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">case</span> MotionEvent.ACTION_UP:<span class="hljs-type"></span><br>   <span class="hljs-comment">/***********省略部分代码******************/</span><br>           <span class="hljs-comment">// Only perform take click actions if we were in the pressed state</span><br>           <span class="hljs-keyword">if</span> (!focusTaken) &#123;<br>               <span class="hljs-comment">// Use a Runnable and post this rather than calling</span><br>               <span class="hljs-comment">// performClick directly. This lets other visual state</span><br>               <span class="hljs-comment">// of the view update before click actions start.</span><br>               <span class="hljs-keyword">if</span> (mPerformClick == <span class="hljs-literal">null</span>) &#123;<br>                   mPerformClick = <span class="hljs-keyword">new</span> <span class="hljs-type">PerformClick</span>();<br>               &#125;<br>               <span class="hljs-keyword">if</span> (!post(mPerformClick)) &#123;<br>                   performClickInternal();<br>               &#125;<br>           &#125;<br>   <span class="hljs-comment">/***********省略部分代码******************/</span><br></code></pre></td></tr></table></figure><p>这里我们主要看核心代码，那就这里执行了<code> performClickInternal()</code>,我们来看看它做了哪些？</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs scss">private boolean <span class="hljs-built_in">performClickInternal</span>() &#123;<br>     <span class="hljs-comment">// Must notify autofill manager before performing the click actions to avoid scenarios where</span><br>     <span class="hljs-comment">// the app has a click listener that changes the state of views the autofill service might</span><br>     <span class="hljs-comment">// be interested on.</span><br>     <span class="hljs-built_in">notifyAutofillManagerOnClick</span>();<br><br>     return <span class="hljs-built_in">performClick</span>();<br> &#125;<br></code></pre></td></tr></table></figure><p>我们看到这个方法很简单直接 return 了<code>performClick()</code>,我们接下来继续看这个方法。</p><h3 id="View-performClick"><a href="#View-performClick" class="headerlink" title="View.performClick()"></a>View.performClick()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">performClick</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// We still need to call this method to handle the cases where performClick() was called</span><br>    <span class="hljs-comment">// externally, instead of through performClickInternal()</span><br>    notifyAutofillManagerOnClick();<br><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> result;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ListenerInfo</span> <span class="hljs-variable">li</span> <span class="hljs-operator">=</span> mListenerInfo;<br>    <span class="hljs-keyword">if</span> (li != <span class="hljs-literal">null</span> &amp;&amp; li.mOnClickListener != <span class="hljs-literal">null</span>) &#123;<br>        playSoundEffect(SoundEffectConstants.CLICK);<br>        li.mOnClickListener.onClick(<span class="hljs-built_in">this</span>);<br>        result = <span class="hljs-literal">true</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        result = <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED);<br><br>    notifyEnterOrExitForAutoFillIfNeeded(<span class="hljs-literal">true</span>);<br><br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个方法中我们会看到，这里它还是获取了<code>mListenerInfo</code>,并且判断了它的<code>OnClickListener</code>是不是为空，如果不为空则执行<code>mOclickListener.onClick()</code>方法。<br>看到这里，大家是不是明白为什么，View 的<code>onClick</code>方法会在最后执行了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这一篇文章我们首先介绍了事件的传递机制，再通过源码分析了 View 的<code>onTouch</code>方法为什么比<code>onClick</code>方法优先执行。我们学习了 View，那我们还知道 Activity 是一个 ViewGroup ，下篇文章我们来分析下手指从触摸屏幕到 Activity 再到 ViewGroup 的传递。<br>下面我们通过一张图来总结以下<code>dispatchTouchEvent</code>方法<br><img src="/android/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%94View%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/img5.png" alt="在这里插入图片描述"><br><strong>推荐阅读</strong></p><ul><li><a href="../Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%94View%E6%98%AF%E5%A6%82%E4%BD%95%E8%A2%AB%E6%B7%BB%E5%8A%A0%E5%88%B0%E5%B1%8F%E5%B9%95%E7%9A%84">Android源码分析——View是如何被添加到屏幕的？</a></li><li><a href="../Android%E7%83%AD%E4%BF%AE%E5%A4%8D%E2%80%94%E2%80%94%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E5%AE%9E%E7%8E%B0AndFix%E7%83%AD%E4%BF%AE%E5%A4%8D">Android热修复——深入剖析AndFix热修复及自己动手实现</a></li><li><a href="https://blog.csdn.net/u013132758/article/details/89181005">深入理解HashMap原理(一)——HashMap源码解析(JDK 1.8)</a><a href="https://bthvi-leiqi.blog.csdn.net/article/details/89354198">深入理解HashMap原理(二)——手写HashMap</a><blockquote><p>欢迎在评论区留下你的观点大家一起交流，一起成长。如果今天的这篇文章对你在工作和生活有所帮助，欢迎<font color="green"><strong>转发</strong></font>分享给更多人。<br></p><p>同时欢迎大家<font color="green"><strong>扫描下方的二维码关注我的公众号</strong></font>大家一起学习交流 Android、HarmonyOS等知识。从这里出发我们一起讨论，一起交流，一起提升。</p></blockquote><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9Wek56NExhdFFNM2czcEI2aFVKODRYRmwxTnFPWlM1ZGJ1NWlhbzJGSzd1TFhqOGdlMDlha2RNWXhpYTZyZFdXbDRENHZGaWEyaWFVQjZpYWU2aWFxUjY5dlM0Zy82NDA?x-oss-process=image/format,png" alt="我的公众号"></li></ul>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>源码解析</tag>
      
      <tag>View</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android源码分析——View是如何被添加到屏幕的</title>
    <link href="/android/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%94View%E6%98%AF%E5%A6%82%E4%BD%95%E8%A2%AB%E6%B7%BB%E5%8A%A0%E5%88%B0%E5%B1%8F%E5%B9%95%E7%9A%84/"/>
    <url>/android/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%94View%E6%98%AF%E5%A6%82%E4%BD%95%E8%A2%AB%E6%B7%BB%E5%8A%A0%E5%88%B0%E5%B1%8F%E5%B9%95%E7%9A%84/</url>
    
    <content type="html"><![CDATA[<p><img src="/android/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%94View%E6%98%AF%E5%A6%82%E4%BD%95%E8%A2%AB%E6%B7%BB%E5%8A%A0%E5%88%B0%E5%B1%8F%E5%B9%95%E7%9A%84/img1.png" alt="head"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在 Android 中，我们知道我们能看到的界面都是 Activity ，但是我们能看到的这些 View 是如何被添加到View中的昵？今天这篇文章我们就通过源码来追踪溯源，看看 View 究竟是如何被添加到手机屏幕上的。本文篇幅较长请大家耐心阅读。</p><h2 id="View-被添加到Activity的步骤"><a href="#View-被添加到Activity的步骤" class="headerlink" title="View 被添加到Activity的步骤"></a>View 被添加到Activity的步骤</h2><p>我们写一个Activity的时候一般都是如下所示的写法来将资源资源加载到了Activity 。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs scala">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AppCompatActivity</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> void onCreate(<span class="hljs-type">Bundle</span> savedInstanceState) &#123;<br>        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState);<br>        setContentView(<span class="hljs-type">R</span>.layout.activity_main);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里我们调用的是 Activity 的 <code>setContentView(@LayoutRes int layoutResID)</code>，那么下面我们继续追踪 Activity 的源码，看看它的 <code>setContentView(@LayoutRes int layoutResID)</code>方法。</p><h3 id="1、Activity-setContentView-int-resourceId"><a href="#1、Activity-setContentView-int-resourceId" class="headerlink" title="1、Activity.setContentView(int resourceId)"></a>1、Activity.setContentView(int resourceId)</h3><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">public</span> <span class="hljs-selector-tag">void</span> <span class="hljs-selector-tag">setContentView</span>(<span class="hljs-variable">@LayoutRes</span> int layoutResID) &#123;<br>       <span class="hljs-selector-tag">getWindow</span>()<span class="hljs-selector-class">.setContentView</span>(layoutResID);<br>       <span class="hljs-selector-tag">initWindowDecorActionBar</span>();<br>   &#125;<br></code></pre></td></tr></table></figure><p>我们这里看到它调用的 <code>getWindow()</code> 获取了一个对象调用了它的 <code>setContentView(layoutResID)</code> 方法。那么我们看下 <code>getWindow()</code> 返回的是什么对象。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-comment">/**</span><br><span class="hljs-comment">   * Retrieve the current &#123;<span class="hljs-doctag">@link</span> android.view.Window&#125; for the activity.</span><br><span class="hljs-comment">   * This can be used to directly access parts of the Window API that</span><br><span class="hljs-comment">   * are not available through Activity/Screen.</span><br><span class="hljs-comment">   *</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@return</span> Window The current window, or null if the activity is not</span><br><span class="hljs-comment">   *         visual.</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-function">Window <span class="hljs-title">getWindow</span><span class="hljs-params">()</span> </span>&#123;<br>      <span class="hljs-keyword">return</span> mWindow;<br>  &#125;<br></code></pre></td></tr></table></figure><p>我们看到这里直接返回了 <code>mWindow</code>,这里我们看注释它说这个方法返回的是当前的 Activity 的 window ,如果当前Activity是不可见的那么返回的是 <code>null</code>。</p><p>我们继续跟踪代码，找到 <code>mWindow</code> 的创建，我们会发现在 <code>attach()</code>方法中，发现对<code>mWindow</code>的赋值。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-type">void</span> <span class="hljs-title">attach</span><span class="hljs-params">(Context context, ActivityThread aThread,</span></span><br><span class="hljs-params"><span class="hljs-function">          Instrumentation instr, IBinder token, <span class="hljs-type">int</span> ident,</span></span><br><span class="hljs-params"><span class="hljs-function">          Application application, Intent intent, ActivityInfo info,</span></span><br><span class="hljs-params"><span class="hljs-function">          CharSequence title, Activity parent, <span class="hljs-type">String</span> id,</span></span><br><span class="hljs-params"><span class="hljs-function">          NonConfigurationInstances lastNonConfigurationInstances,</span></span><br><span class="hljs-params"><span class="hljs-function">          Configuration config, <span class="hljs-type">String</span> referrer, IVoiceInteractor voiceInteractor,</span></span><br><span class="hljs-params"><span class="hljs-function">          Window window, ActivityConfigCallback activityConfigCallback)</span> </span>&#123;<br>      <span class="hljs-built_in">attachBaseContext</span>(context);<br><br>      mFragments.<span class="hljs-built_in">attachHost</span>(null <span class="hljs-comment">/*parent*/</span>);<br><br>      mWindow = <span class="hljs-keyword">new</span> <span class="hljs-built_in">PhoneWindow</span>(<span class="hljs-keyword">this</span>, window, activityConfigCallback);<br>     <br>     <span class="hljs-comment">/***********省略部分代码*****************/</span><br>     <br>      &#125;<br></code></pre></td></tr></table></figure><p>我们这里看到<code>mWindow</code>是一个 <code>PhoneWindow</code>对象，所以这里调用了 <code>PhoneWindow</code> 的 <code>setContentView(layoutResID)</code> 方法。</p><h3 id="2、PhoneWindow-setContentView-int-layoutResID"><a href="#2、PhoneWindow-setContentView-int-layoutResID" class="headerlink" title="2、PhoneWindow.setContentView(int layoutResID)"></a>2、PhoneWindow.setContentView(int layoutResID)</h3><p>我们接着来看<code>PhoneWindow.setContentView(int layoutResID)</code>的源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setContentView</span><span class="hljs-params">(<span class="hljs-type">int</span> layoutResID)</span> &#123;<br>    <span class="hljs-comment">// Note: FEATURE_CONTENT_TRANSITIONS may be set in the process of installing the window</span><br>    <span class="hljs-comment">// decor, when theme attributes and the like are crystalized. Do not check the feature</span><br>    <span class="hljs-comment">// before this happens.</span><br>    <span class="hljs-keyword">if</span> (mContentParent == <span class="hljs-literal">null</span>) &#123;<br>        installDecor();<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;<br>        mContentParent.removeAllViews();<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Scene</span> <span class="hljs-variable">newScene</span> <span class="hljs-operator">=</span> Scene.getSceneForLayout(mContentParent, layoutResID,<br>                getContext());<br>        transitionTo(newScene);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        mLayoutInflater.inflate(layoutResID, mContentParent);<br>    &#125;<br>    mContentParent.requestApplyInsets();<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Callback</span> <span class="hljs-variable">cb</span> <span class="hljs-operator">=</span> getCallback();<br>    <span class="hljs-keyword">if</span> (cb != <span class="hljs-literal">null</span> &amp;&amp; !isDestroyed()) &#123;<br>        cb.onContentChanged();<br>    &#125;<br>    mContentParentExplicitlySet = <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们从第一行看，首先判断了<code>mContentParent</code>是不是为<code>null</code>,如果为<code>null</code>,执行了<code>indtallDecor()</code>方法，下面我们继续看它的源码。</p><h4 id="2-1-installDecor"><a href="#2-1-installDecor" class="headerlink" title="2.1 installDecor()"></a>2.1 installDecor()</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">installDecor</span>()</span> &#123;<br>    mForceDecorInstall = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span> (mDecor == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">//初始化 DecorView</span><br>        mDecor = generateDecor(<span class="hljs-number">-1</span>);<br>        mDecor.setDescendantFocusability(ViewGroup.FOCUS_AFTER_DESCENDANTS);<br>        mDecor.setIsRootNamespace(<span class="hljs-literal">true</span>);<br>        <span class="hljs-keyword">if</span> (!mInvalidatePanelMenuPosted &amp;&amp; mInvalidatePanelMenuFeatures != <span class="hljs-number">0</span>) &#123;<br>            mDecor.postOnAnimation(mInvalidatePanelMenuRunnable);<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">//给 DecorView 设置 PhoneWindow</span><br>        mDecor.setWindow(<span class="hljs-keyword">this</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (mContentParent == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">//初始化 mContentParent</span><br>        mContentParent = generateLayout(mDecor);<br><br>        <span class="hljs-comment">// Set up decor part of UI to ignore fitsSystemWindows if appropriate.</span><br>        <span class="hljs-comment">//设置 DecorView 忽略fitsSystemWindows</span><br>        mDecor.makeOptionalFitsSystemWindows();<br><br>     <span class="hljs-comment">/*************省略部分代码************************/</span><br>     <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这部分代码中我们首先看到在第三行对<code>mDecor</code>做了初始化，这里的<code>mDecor</code>就是<code>DecorView</code>。然后如果<code>mDecor</code>不为null的话将当前的Window设置到 DecorView 。后面判断了 <code>mContentParent</code> 是不是为空，为空则初始化 mContentParent。总结起来这个方法中做了下面几件事：</p><ol><li>如果 mDevor 为空调用<code>generateDecor(-1)</code>初始化 DecorView；</li><li>如果 mDecor 不为空则给 DecorView 设置当前 PhoneWindow；</li><li>如果mContentParent为空则初始化 mContentParent；</li></ol><p>下面我们分别来看这我们首先看下<code>generateDecor(-1)</code>方法是如何初始化 <code>DecorView</code>的。</p><h5 id="I、初始化DevoreView"><a href="#I、初始化DevoreView" class="headerlink" title="I、初始化DevoreView"></a>I、初始化DevoreView</h5><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">protected</span> DecorView generateDecor(<span class="hljs-keyword">int</span> featureId) &#123;<br>    Context <span class="hljs-keyword">context</span>;<br>    <span class="hljs-keyword">if</span> (mUseDecorContext) &#123;<br>        Context applicationContext = getContext()<span class="hljs-variable">.getApplicationContext</span>();<br>        <span class="hljs-keyword">if</span> (applicationContext == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">context</span> = getContext();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">context</span> = <span class="hljs-keyword">new</span> DecorContext(applicationContext, getContext());<br>            <span class="hljs-keyword">if</span> (mTheme != -<span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-keyword">context</span><span class="hljs-variable">.setTheme</span>(mTheme);<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">context</span> = getContext();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DecorView(<span class="hljs-keyword">context</span>, featureId, <span class="hljs-keyword">this</span>, getAttributes());<br>&#125;<br></code></pre></td></tr></table></figure><p>这里我们看到这个方法比较件单，它的返回值是直接 new 了一个 DecorView 对象。<br>下面我们来看 <code>mDecor.setWindow(this)</code>。</p><h5 id="II、mDecor-setWindow-this"><a href="#II、mDecor-setWindow-this" class="headerlink" title="II、mDecor.setWindow(this)"></a>II、mDecor.setWindow(this)</h5><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs abnf">void setWindow(PhoneWindow phoneWindow) &#123;<br>    mWindow <span class="hljs-operator">=</span> phoneWindow<span class="hljs-comment">;</span><br>    Context context <span class="hljs-operator">=</span> getContext()<span class="hljs-comment">;</span><br>    if (context instanceof DecorContext) &#123;<br>        DecorContext decorContext <span class="hljs-operator">=</span> (DecorContext) context<span class="hljs-comment">;</span><br>        decorContext.setPhoneWindow(mWindow)<span class="hljs-comment">;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个方法也是非常件单，就是将传入的<code>PhoneWindow</code>对象赋值给<code>DecorView</code>中的<code>window</code>属性。</p><h5 id="III、初始化mContentParent"><a href="#III、初始化mContentParent" class="headerlink" title="III、初始化mContentParent"></a>III、初始化mContentParent</h5><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs awk">protected ViewGroup generateLayout(DecorView decor) &#123;<br><br><span class="hljs-regexp">/****************省略部分代码***************************/</span><br><br>    <span class="hljs-regexp">//</span> Inflate the window decor.<br>    int layoutResource;<br>    int features = getLocalFeatures();<br>    <span class="hljs-regexp">//</span> System.out.println(<span class="hljs-string">&quot;Features: 0x&quot;</span> + Integer.toHexString(features));<br>    <span class="hljs-keyword">if</span> ((features &amp; (<span class="hljs-number">1</span> &lt;&lt; FEATURE_SWIPE_TO_DISMISS)) != <span class="hljs-number">0</span>) &#123;<br>        layoutResource = R.layout.screen_swipe_dismiss;<br>        setCloseOnSwipeEnabled(true);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((features &amp; ((<span class="hljs-number">1</span> &lt;&lt; FEATURE_LEFT_ICON) | (<span class="hljs-number">1</span> &lt;&lt; FEATURE_RIGHT_ICON))) != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> (mIsFloating) &#123;<br>            TypedValue res = new TypedValue();<br>            getContext().getTheme().resolveAttribute(<br>                    R.attr.dialogTitleIconsDecorLayout, res, true);<br>            layoutResource = res.resourceId;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            layoutResource = R.layout.screen_title_icons;<br>        &#125;<br>        <span class="hljs-regexp">//</span> XXX Remove this once action bar supports these features.<br>        removeFeature(FEATURE_ACTION_BAR);<br>        <span class="hljs-regexp">//</span> System.out.println(<span class="hljs-string">&quot;Title Icons!&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((features &amp; ((<span class="hljs-number">1</span> &lt;&lt; FEATURE_PROGRESS) | (<span class="hljs-number">1</span> &lt;&lt; FEATURE_INDETERMINATE_PROGRESS))) != <span class="hljs-number">0</span><br>            &amp;&amp; (features &amp; (<span class="hljs-number">1</span> &lt;&lt; FEATURE_ACTION_BAR)) == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-regexp">//</span> Special case <span class="hljs-keyword">for</span> a window with only a progress bar (and title).<br>        <span class="hljs-regexp">//</span> XXX Need to have a no-title version of embedded windows.<br>        layoutResource = R.layout.screen_progress;<br>        <span class="hljs-regexp">//</span> System.out.println(<span class="hljs-string">&quot;Progress!&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((features &amp; (<span class="hljs-number">1</span> &lt;&lt; FEATURE_CUSTOM_TITLE)) != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-regexp">//</span> Special case <span class="hljs-keyword">for</span> a window with a custom title.<br>        <span class="hljs-regexp">//</span> If the window is floating, we need a dialog layout<br>        <span class="hljs-keyword">if</span> (mIsFloating) &#123;<br>            TypedValue res = new TypedValue();<br>            getContext().getTheme().resolveAttribute(<br>                    R.attr.dialogCustomTitleDecorLayout, res, true);<br>            layoutResource = res.resourceId;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            layoutResource = R.layout.screen_custom_title;<br>        &#125;<br>        <span class="hljs-regexp">//</span> XXX Remove this once action bar supports these features.<br>        removeFeature(FEATURE_ACTION_BAR);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((features &amp; (<span class="hljs-number">1</span> &lt;&lt; FEATURE_NO_TITLE)) == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-regexp">//</span> If no other features and not embedded, only need a title.<br>        <span class="hljs-regexp">//</span> If the window is floating, we need a dialog layout<br>        <span class="hljs-keyword">if</span> (mIsFloating) &#123;<br>            TypedValue res = new TypedValue();<br>            getContext().getTheme().resolveAttribute(<br>                    R.attr.dialogTitleDecorLayout, res, true);<br>            layoutResource = res.resourceId;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((features &amp; (<span class="hljs-number">1</span> &lt;&lt; FEATURE_ACTION_BAR)) != <span class="hljs-number">0</span>) &#123;<br>            layoutResource = a.getResourceId(<br>                    R.styleable.Window_windowActionBarFullscreenDecorLayout,<br>                    R.layout.screen_action_bar);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            layoutResource = R.layout.screen_title;<br>        &#125;<br>        <span class="hljs-regexp">//</span> System.out.println(<span class="hljs-string">&quot;Title!&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((features &amp; (<span class="hljs-number">1</span> &lt;&lt; FEATURE_ACTION_MODE_OVERLAY)) != <span class="hljs-number">0</span>) &#123;<br>        layoutResource = R.layout.screen_simple_overlay_action_mode;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-regexp">//</span> Embedded, so no decoration is needed.<br>        layoutResource = R.layout.screen_simple;<br>        <span class="hljs-regexp">//</span> System.out.println(<span class="hljs-string">&quot;Simple!&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span>我是华丽的分隔线<span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><br>    <br>    mDecor.startChanging();<br>    mDecor.onResourcesLoaded(mLayoutInflater, layoutResource);<br><br>    ViewGroup contentParent = (ViewGroup)findViewById(ID_ANDROID_CONTENT);<br>    <span class="hljs-keyword">if</span> (contentParent == null) &#123;<br>        throw new RuntimeException(<span class="hljs-string">&quot;Window couldn&#x27;t find content container view&quot;</span>);<br>    &#125;<br>    <br>   <span class="hljs-regexp">/****************省略部分代码***************************/</span><br>  <br>    return  contentParent；<br>&#125;        <br></code></pre></td></tr></table></figure><p>这里我们看到主要有两部分文中的代码，我们可以看到分隔线以上的那一大段<code>if/else</code>是根据不同的条件给<code>layoutResource</code>赋值的。这一大段代码就是根据我们设置的<code>Application</code>的主题去选择对应加载的资源布局 Id。<br>然后我们看到紧接着调用的<code>DecorView</code>的<code>onResourcesLoaded(mLayoutInflater, layoutResource)</code>方法，那么我们继续看这个方法具体做了哪些事情</p><h6 id="onResourcesLoaded"><a href="#onResourcesLoaded" class="headerlink" title="onResourcesLoaded"></a>onResourcesLoaded</h6><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">onResourcesLoaded</span><span class="hljs-params">(LayoutInflater inflater, <span class="hljs-type">int</span> layoutResource)</span> </span>&#123;<br>    <span class="hljs-comment">/**************省略部分代码**************************/</span><br>        <span class="hljs-keyword">final</span> View root = inflater.<span class="hljs-built_in">inflate</span>(layoutResource, null);<br>       <span class="hljs-comment">/**************省略部分代码**************************/</span><br>            <span class="hljs-comment">// Put it below the color views.</span><br>            <span class="hljs-built_in">addView</span>(root, <span class="hljs-number">0</span>, <span class="hljs-keyword">new</span> ViewGroup.<span class="hljs-built_in">LayoutParams</span>(MATCH_PARENT, MATCH_PARENT));<br>        &#125;<br>        mContentRoot = (ViewGroup) root;<br>        <span class="hljs-built_in">initializeElevation</span>();<br>    &#125;<br></code></pre></td></tr></table></figure><p>我们这里还是看核心部分的代码，这里我们看到首先将传进来的资源布局进行<code>inflate</code>并把它赋值给<code>root</code>，然后将<code>root</code>添加到<code>DecorView</code>中。一句话来说就是<code> mDecor.onResourcesLoaded(mLayoutInflater, layoutResource);</code>这句代码是<font color="green">将对应的资源布局文件加载到<code>mDecor</code></font>。<br>下面我们继续来看<code>generateLayout(DecorView decor)</code>方法，我们发现下面它对<code>contentParent</code>通过<code>findViewById(ID_ANDROID_CONTENT)</code>进行了赋值。那么我们看下<code>ID_ANDROID_CONTENT</code>对应的 ID 值。</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-comment">/**</span><br><span class="hljs-comment">   * The ID that the main layout in the XML layout file should have.</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-built_in">int</span> ID_ANDROID_CONTENT = com.android.<span class="hljs-keyword">internal</span>.R.id.content;<br></code></pre></td></tr></table></figure><p>注释中说这个 ID 是主布局的 XML 中必须存在的。也就是之前赋值的<code>layoutResource</code>中必须存在的。我们随便找一个上面的 xml 布局文件来来看看.</p><h6 id="R-layout-screen-simple"><a href="#R-layout-screen-simple" class="headerlink" title="R.layout.screen_simple"></a>R.layout.screen_simple</h6><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">LinearLayout</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:fitsSystemWindows</span>=<span class="hljs-string">&quot;true&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:orientation</span>=<span class="hljs-string">&quot;vertical&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">ViewStub</span> <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/action_mode_bar_stub&quot;</span></span><br><span class="hljs-tag">              <span class="hljs-attr">android:inflatedId</span>=<span class="hljs-string">&quot;@+id/action_mode_bar&quot;</span></span><br><span class="hljs-tag">              <span class="hljs-attr">android:layout</span>=<span class="hljs-string">&quot;@layout/action_mode_bar&quot;</span></span><br><span class="hljs-tag">              <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">              <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">              <span class="hljs-attr">android:theme</span>=<span class="hljs-string">&quot;?attr/actionBarTheme&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">FrameLayout</span></span><br><span class="hljs-tag">         <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@android:id/content&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">android:foregroundInsidePadding</span>=<span class="hljs-string">&quot;false&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">android:foregroundGravity</span>=<span class="hljs-string">&quot;fill_horizontal|top&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">android:foreground</span>=<span class="hljs-string">&quot;?android:attr/windowContentOverlay&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">LinearLayout</span>&gt;</span><br></code></pre></td></tr></table></figure><p>我们看到<code>R.id.content</code>确实是存在的,并且它是一个<code>FrameLayout</code>。到这里我们来看下现在前面这些具体做了哪些？<br>如下图所示，到这里 Activity 持有一个 PhoneWindow 对象，PhoneWindow 中有一个 DecorView ，DecorView 中加载了一个基础的资源布局，里面有 title,ActionBar 等，肯定存在一个 id 为 <code>R.id.ccontent</code> 的资源布局。<br><img src="/android/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%94View%E6%98%AF%E5%A6%82%E4%BD%95%E8%A2%AB%E6%B7%BB%E5%8A%A0%E5%88%B0%E5%B1%8F%E5%B9%95%E7%9A%84/img2.png" alt="资源布局"></p><p>看到这里就完了？不不不，还有我们继续往下看！！！</p><h3 id="2-2-mLayoutInflater-inflate-layoutResID-mContentParent"><a href="#2-2-mLayoutInflater-inflate-layoutResID-mContentParent" class="headerlink" title="2.2 mLayoutInflater.inflate(layoutResID, mContentParent)"></a>2.2 mLayoutInflater.inflate(layoutResID, mContentParent)</h3><p>我们继续回到<code>PhoneWiondow</code>的<code>setContentView(int layoutResID)</code>,如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setContentView</span><span class="hljs-params">(<span class="hljs-type">int</span> layoutResID)</span> &#123;<br>    <span class="hljs-comment">// Note: FEATURE_CONTENT_TRANSITIONS may be set in the process of installing the window</span><br>    <span class="hljs-comment">// decor, when theme attributes and the like are crystalized. Do not check the feature</span><br>    <span class="hljs-comment">// before this happens.</span><br>    <span class="hljs-keyword">if</span> (mContentParent == <span class="hljs-literal">null</span>) &#123;<br>        installDecor();<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;<br>        mContentParent.removeAllViews();<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Scene</span> <span class="hljs-variable">newScene</span> <span class="hljs-operator">=</span> Scene.getSceneForLayout(mContentParent, layoutResID,<br>                getContext());<br>        transitionTo(newScene);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        mLayoutInflater.inflate(layoutResID, mContentParent);<br>    &#125;<br>    mContentParent.requestApplyInsets();<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Callback</span> <span class="hljs-variable">cb</span> <span class="hljs-operator">=</span> getCallback();<br>    <span class="hljs-keyword">if</span> (cb != <span class="hljs-literal">null</span> &amp;&amp; !isDestroyed()) &#123;<br>        cb.onContentChanged();<br>    &#125;<br>    mContentParentExplicitlySet = <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们前面看完了<code>installDecor()</code>方法，我们继续往下看，我们看到下面紧接着调用了<code> mLayoutInflater.inflate(layoutResID, mContentParent);</code>将之前 Activity 中从传入的资源布局加载到我们前面初始化的<code>mContentParent</code>中，也就是在资源ID为<code>R.id.ccontent</code>的 Framlayout 中。现在我们来看看我们传进来的资源布局文件被加载到哪里了？<br><img src="/android/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%94View%E6%98%AF%E5%A6%82%E4%BD%95%E8%A2%AB%E6%B7%BB%E5%8A%A0%E5%88%B0%E5%B1%8F%E5%B9%95%E7%9A%84/img3.png" alt="资源布局"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇文章我们从 Ativity 的 setContentView(layoutResourceId) 开始，一步步追踪 Android FrameWork 层的源码。探究了我们平时代码中写的资源布局是如何被加载到 Activity 中的。我们根据源码简单画了一个流程图如下：<br><img src="/android/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%94View%E6%98%AF%E5%A6%82%E4%BD%95%E8%A2%AB%E6%B7%BB%E5%8A%A0%E5%88%B0%E5%B1%8F%E5%B9%95%E7%9A%84/img4.png" alt="View被添加到Activity流程图"></p><blockquote><p>欢迎在评论区留下你的观点大家一起交流，一起成长。如果今天的这篇文章对你在工作和生活有所帮助，欢迎<font color="green"><strong>转发</strong></font>分享给更多人。<br></p><p>同时欢迎大家<font color="green"><strong>扫描下方的二维码关注我的公众号</strong></font>大家一起学习交流 Android、HarmonyOS等知识。从这里出发我们一起讨论，一起交流，一起提升。</p></blockquote><p><img src="/android/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%94View%E6%98%AF%E5%A6%82%E4%BD%95%E8%A2%AB%E6%B7%BB%E5%8A%A0%E5%88%B0%E5%B1%8F%E5%B9%95%E7%9A%84/img5.png" alt="我的公众号"></p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>源码解析</tag>
      
      <tag>View</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android热修复——自己动手实现AndFix热修复</title>
    <link href="/android/Android%E7%83%AD%E4%BF%AE%E5%A4%8D%E2%80%94%E2%80%94%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E5%AE%9E%E7%8E%B0AndFix%E7%83%AD%E4%BF%AE%E5%A4%8D/"/>
    <url>/android/Android%E7%83%AD%E4%BF%AE%E5%A4%8D%E2%80%94%E2%80%94%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E5%AE%9E%E7%8E%B0AndFix%E7%83%AD%E4%BF%AE%E5%A4%8D/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前面写过一篇热修复的文章<a href="../Android%E7%83%AD%E4%BF%AE%E5%A4%8D%E2%80%94%E2%80%94%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E5%AE%9E%E7%8E%B0Android%E7%83%AD%E4%BF%AE%E5%A4%8D">Android热修复——手把手教你实现Android热修复</a>，那时候刚开始接触，照猫画虎画的还算比较成功。但是那种修复需要重新启动APP，也就是在JAVA层实现的热修复。我们知道目前Android主流的修复还有在Native层实现修复的，就是在Native层替换方法，不用重新启动APP。今天写了个Demo，下面主要分享一下它的主要原理。</p><h2 id="1、热修复"><a href="#1、热修复" class="headerlink" title="1、热修复"></a>1、热修复</h2><p>目前，热修复的原理主要有两种技术,一是不需要启动APP就能实现修复，在Native层实现的。一种时需要启动APP，在JAVA层实现的。</p><ul><li><strong>Native层</strong>:andfix sophix  （即时修复  不重启APP）</li><li><strong>JAVA层</strong>:Tinker robust等（需要启动APP）</li></ul><h3 id="出现异常的根源在于方法"><a href="#出现异常的根源在于方法" class="headerlink" title="出现异常的根源在于方法"></a>出现异常的根源在于方法</h3><p>我们的程序出现异常(BUG)的根源是什么？为什么会出现异常呢，要出现异常肯定是我们程序中的<strong>某个方法</strong>抛出了异常，所以异常的根源是<font color="red" style="blod"><strong>方法</strong></font>。那么我们修复包的目的就是去替换异常的方法所在的包名类名下的方法。我们需要准确的找到这个方法，那么我们怎么去找这个方法呢？</p><h3 id="如何替换已经运行的APK-？"><a href="#如何替换已经运行的APK-？" class="headerlink" title="如何替换已经运行的APK ？"></a>如何替换已经运行的APK ？</h3><p>是直接替换运行时的APK加载的有bug的类吗？显然不行，因为<strong>Java的懒加载机制，在不启动APP时新类不能替换老的类</strong>。class类只被ClassLoader加载一次，所以已经有bug的类,再不启动APP的情况下我们不能直接再虚拟机中替换。那我们要怎么去做呢？我们根据JAVA的内存运行机制来寻找有没有突破口。</p><h2 id="2、class加载-内存运行机制"><a href="#2、class加载-内存运行机制" class="headerlink" title="2、class加载(内存运行机制)"></a>2、class加载(内存运行机制)</h2><p>Java虚拟机（JVM）在java程序运行的过程中，会将它所管理的内存划分为若干个不同的数据区域，这些区域有的随着JVM的启动而创建，有的随着用户线程的启动和结束而建立和销毁。一个基本的JVM运行时内存模型如下所示：<br><img src="/android/Android%E7%83%AD%E4%BF%AE%E5%A4%8D%E2%80%94%E2%80%94%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E5%AE%9E%E7%8E%B0AndFix%E7%83%AD%E4%BF%AE%E5%A4%8D/img1.png" alt="img"><br>我们分别看下它的运行时数据区</p><ul><li><strong>方法区</strong>：class会被加载到方法区，当JVM使用类加载器定位class文件，并将其载入到内存中，会提取class文件的类型信息，并将这些信息存储到方法区中，同时，放入方法区中的还有该类型中的类静态变量。【方法表，静态变量，】</li><li><strong>堆区</strong>： Java程序在运行时创建的所有类型对象和数组都存储在堆中&#x2F;JVM会根据new指令在堆中开辟一个确定类型的对象内存空间。但是堆中开辟对象的空间并没有任何人工指令可以回收，而是通过JVM的垃圾回收器负责回收。</li><li><strong>栈区</strong>：方法的执行是在虚拟机，Java方法执行存储在栈区，每个Java方法对应一个栈帧。每启动一个线程，JVM都会为它分配一个Java栈，用于存放方法中的<strong>局部变量，操作数以及异常数据</strong>等。当线程调用某个方法时，JVM会根据方法区中该方法的字节码组建一个栈帧，并将该栈帧压入Java栈中，方法执行完毕时，JVM会弹出该方法栈并释放掉。</li><li>**本地方法栈(Native 堆)**： 本地方法栈的功能和特点类似于虚拟机栈，不同的是，本地方法栈服务的对象是JVM执行的native方法，而虚拟机栈服务的是JVM执行的java方法。</li><li><strong>程序计数器(PC寄存器)<strong>：</strong>程序计数器是一个记录着当前线程所执行的字节码的行号指示器。</strong> JAVA代码编译后的字节码在未经过JIT（实时编译器）编译前，其执行方式是通过“字节码解释器”进行解释执行。简单的工作原理为解释器读取装载入内存的字节码，按照顺序读取字节码指令。读取一个指令后，将该指令“翻译”成固定的操作，并根据这些操作进行分支、循环、跳转等流程。</li></ul><p>当手指触摸APP ICON启动APP的流程如下：<br><img src="/android/Android%E7%83%AD%E4%BF%AE%E5%A4%8D%E2%80%94%E2%80%94%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E5%AE%9E%E7%8E%B0AndFix%E7%83%AD%E4%BF%AE%E5%A4%8D/img2.png" alt="启动流程"><br>类加载之前有个，int型符号变量指向class内存区域，即将要加载class类信息。（字节码文件内有方法、成员变量）</p><h3 id="加载过程由文件变成内存的过程"><a href="#加载过程由文件变成内存的过程" class="headerlink" title="加载过程由文件变成内存的过程"></a>加载过程由文件变成内存的过程</h3><ol><li>加载ActivityThread 生成方法表</li><li>加载main()函数</li><li>虚拟机将main()函数压栈，生成一个栈帧，压入栈区。</li><li>加载Application.class,生成它的方法表。</li><li>创建Application的对象，存放在堆区。每个对象都指向一个符号变量（类）</li><li>Object.getClass()得到变量对应的类,最终是通过native方法，最终执行调用<code>klass</code>变量，他存放在堆区，指向符号变量，符号变量指向对象所在的内存区域（方法表，成员表）。</li><li>执行<code>Application</code>的<code>onCreate()</code>方法，他是一个对象方法，执行一个对象方法他会从对象出发，去发送一个事件。根据符号变量找打方法表，找到<code>onCreate()</code>方法，并生成一个<code>onCreate()</code>栈帧，压入栈区。</li></ol><h3 id="类什么时候被加载到内存？"><a href="#类什么时候被加载到内存？" class="headerlink" title="类什么时候被加载到内存？"></a>类什么时候被加载到内存？</h3><pre><code class="hljs">1、Application app   2、=  new Application();</code></pre><p>执行到第一行在方法区开辟一个符号变量，这个符号变量为int类型。并不会将<code>Application</code>类加载到内存。当执行第二行时才会被加载到内存。<code>类的初始化只有在主动引用这时候才会被加载到内存，如new创建 | 反射 Class.fromName()|JNI.findClass()、序列化</code></p><h3 id="如何实现替换有bug的方法？"><a href="#如何实现替换有bug的方法？" class="headerlink" title="如何实现替换有bug的方法？"></a>如何实现替换有bug的方法？</h3><ol><li>根据以上原理我们明白，Java层不能实现方法的替换，那么我们另辟蹊径，通过<font color="red"><strong>Native层操控虚拟机内存</strong></font>,这就是我们前面所说的突破口。</li><li>由于java对象可以创建多个，我们不能替换某一个对象而不替换其他对象的方法，所以我们需要找打一个方法替换所有对象的方法。那就是需要在方法表中替换有bug 的方法。</li><li>方法在虚拟机中叫<code>ArtMethod</code>结构体，它是Native层的。方法表其实就是一个List集合。方法最终是转换为<code>ArtMethod</code>结构体被执行。一个方法被压栈多次这个方法就是递归调用。</li><li>FindClass(实现父委托机制，bootstrapClassLoad) 调用 LookUpClass —&gt;DefineClass(定义一个Class类型，定义klass，所有类型全部置空，之后再加载类)—&gt;LinkClass(加载类信息。从&#x2F;data&#x2F;app&#x2F;包名，Apk中的dex文件中来)—&gt;LinkSuperClass(父类先被加载到内存)—&gt;LinkMethods(父类加载方法){LinkInterfaceMethods 拿到方法数，形成方法表，实例一个ArrayList&lt;<code>ArtMethod</code>&gt;,每个方法实例一个<code>ArtMethod</code>结构体}</li></ol><p>类是抽象的,必须要有一个内存载体{klass,每个类都有一个，并且是唯一的.}</p><h2 id="3、手写实现Andfix"><a href="#3、手写实现Andfix" class="headerlink" title="3、手写实现Andfix"></a>3、手写实现Andfix</h2><h3 id="写一个bug类"><a href="#写一个bug类" class="headerlink" title="写一个bug类"></a>写一个bug类</h3><p>   首先我们要自己写一个bug类，<code>BugClass</code>的<code>test()</code>方法抛出一个异常</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * bug测试类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">BugClass</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">test</span>()</span>&#123;<br>        <span class="hljs-comment">//测试bug</span><br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;这是一个异常！&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="在Activity中调用异常的方法"><a href="#在Activity中调用异常的方法" class="headerlink" title="在Activity中调用异常的方法"></a>在Activity中调用异常的方法</h3><pre><code class="hljs">比如说点击某个按钮，这里就不写了。</code></pre><h3 id="我们要实现修复"><a href="#我们要实现修复" class="headerlink" title="我们要实现修复"></a>我们要实现修复</h3><pre><code class="hljs">我们实现修复，也就是之前说的替换虚拟机中内存中的方法表里的方法，那么怎么替换呢？一个APK中有成千上万个方法，就某一个有异常，我们怎么区分呢？那就是用注解来区分。</code></pre><h4 id="定义注解"><a href="#定义注解" class="headerlink" title="定义注解"></a>定义注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.example.bthvi.mycloassloaderapplication;<br><br><span class="hljs-keyword">import</span> java.lang.annotation.ElementType;<br><span class="hljs-keyword">import</span> java.lang.annotation.Retention;<br><span class="hljs-keyword">import</span> java.lang.annotation.RetentionPolicy;<br><span class="hljs-keyword">import</span> java.lang.annotation.Target;<br><br><span class="hljs-meta">@Target(ElementType.METHOD)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Replace &#123;<br>    <span class="hljs-comment">//修复哪一个class</span><br>    String <span class="hljs-title function_">clazz</span><span class="hljs-params">()</span>;<br>    <span class="hljs-comment">//修复哪一个方法</span><br>    String <span class="hljs-title function_">method</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="修复对应方法所，并给他加上注解"><a href="#修复对应方法所，并给他加上注解" class="headerlink" title="修复对应方法所，并给他加上注解"></a>修复对应方法所，并给他加上注解</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">import</span> com.example.bthvi.mycloassloaderapplication.Replace;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * bug测试类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BugClass</span> &#123;<br><br>    <span class="hljs-meta">@Replace(clazz = <span class="hljs-string">&quot;com.example.bthvi.mycloassloaderapplication.xxx.BugClass&quot;</span>,method = <span class="hljs-string">&quot;test&quot;</span>)</span><br>    <span class="hljs-keyword">public</span> int test()&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="生成dex文件查分包"><a href="#生成dex文件查分包" class="headerlink" title="生成dex文件查分包"></a>生成dex文件查分包</h4><p>   怎么生成dex文件，前面一篇文章以及说过了:<a href="../Android%E7%83%AD%E4%BF%AE%E5%A4%8D%E2%80%94%E2%80%94%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E5%AE%9E%E7%8E%B0Android%E7%83%AD%E4%BF%AE%E5%A4%8D/">Android学习——手把手教你实现Android热修复</a>,这里就不多做说明了。</p><h4 id="实现修复工具类"><a href="#实现修复工具类" class="headerlink" title="实现修复工具类"></a>实现修复工具类</h4><ul><li>首先我们要拿到对应的已经修复的dex文件，项目中我们肯定是从网络和获取，这里我们之还是定义在本地文件夹下。</li><li>其次我们加载这个Dex文件，拿到它的所有的类，遍历类中的方法，根据注解得到哪些方法时候需要修复的。</li><li>再根据注解中的类名方法名通过反射得到已经加载的有bug的方法。</li><li>调用Native方法替换有bug的方法。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.example.bthvi.mycloassloaderapplication;<br><span class="hljs-keyword">import</span> android.content.Context;<br><span class="hljs-keyword">import</span> android.os.Environment;<br><br><span class="hljs-keyword">import</span> java.io.File;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><span class="hljs-keyword">import</span> java.util.Enumeration;<br><br><span class="hljs-keyword">import</span> dalvik.system.DexFile;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *<span class="hljs-doctag">@author</span> bthvi</span><br><span class="hljs-comment"> *<span class="hljs-doctag">@time</span> 2019/7/20</span><br><span class="hljs-comment"> *<span class="hljs-doctag">@desc</span> 不用启动APP实现热修复</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FixDexManager</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">TAG</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;FixDexUtil&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">DEX_SUFFIX</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;.dex&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">APK_SUFFIX</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;.apk&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">JAR_SUFFIX</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;.jar&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">ZIP_SUFFIX</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;.zip&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">DEX_DIR</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;odex&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">OPTIMIZE_DEX_DIR</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;optimize_dex&quot;</span>;<br>    <span class="hljs-keyword">private</span> Context context;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">FixDexManager</span><span class="hljs-params">(Context context)</span> &#123;<br>        <span class="hljs-built_in">this</span>.context = context;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">isGoingToFix</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">File</span> <span class="hljs-variable">externalStorageDirectory</span> <span class="hljs-operator">=</span> Environment.getExternalStorageDirectory();<br><br>        <span class="hljs-comment">// 遍历所有的修复dex , 因为可能是多个dex修复包</span><br>        <span class="hljs-type">File</span> <span class="hljs-variable">fileDir</span> <span class="hljs-operator">=</span> externalStorageDirectory != <span class="hljs-literal">null</span> ?<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(externalStorageDirectory,<span class="hljs-string">&quot;007&quot;</span>):<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(context.getFilesDir(), DEX_DIR);<span class="hljs-comment">// data/data/包名/files/odex（这个可以任意位置）</span><br><br>        File[] listFiles = fileDir.listFiles();<br>        <span class="hljs-keyword">if</span> (listFiles != <span class="hljs-literal">null</span>)&#123;<br>            System.out.println(<span class="hljs-string">&quot;TAG==目录下文件数量=&quot;</span>+listFiles.length);<br>            <span class="hljs-keyword">for</span> (File file : listFiles) &#123;<br>                System.out.println(<span class="hljs-string">&quot;TAG==文件名称=&quot;</span>+file.getName());<br>                <span class="hljs-keyword">if</span> (file.getName().startsWith(<span class="hljs-string">&quot;fix&quot;</span>) &amp;&amp;<br>                        (file.getName().endsWith(DEX_SUFFIX))) &#123;<br>                    loadDex(file);<span class="hljs-comment">// 开始修复</span><br>                    <span class="hljs-comment">//有目标dex文件, 需要修复</span><br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 加载Dex文件</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> file</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">loadDex</span><span class="hljs-params">(File file)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">DexFile</span> <span class="hljs-variable">dexFile</span> <span class="hljs-operator">=</span> DexFile.loadDex(file.getAbsolutePath(),<br>                    <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(context.getCacheDir(), <span class="hljs-string">&quot;opt&quot;</span>).getAbsolutePath(), Context.MODE_PRIVATE);<br>            <span class="hljs-comment">//当前的dex里面的class 类名集合</span><br>            Enumeration&lt;String&gt; entry=dexFile.entries();<br>            <span class="hljs-keyword">while</span> (entry.hasMoreElements()) &#123;<br>                <span class="hljs-comment">//拿到Class类名</span><br>                String clazzName= entry.nextElement();<br>                <span class="hljs-comment">//通过加载得到类  这里不能通过反射，因为当前的dex没有加载到虚拟机内存中</span><br>                Class realClazz= dexFile.loadClass(clazzName, context.getClassLoader());<br>                <span class="hljs-keyword">if</span> (realClazz != <span class="hljs-literal">null</span>) &#123;<br>                    fixClazz(realClazz);<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 修复有bug的方法</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> realClazz</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fixClazz</span><span class="hljs-params">(Class realClazz)</span> &#123;<br>        <span class="hljs-comment">//得到类中所有方法</span><br>        Method[] methods=realClazz.getMethods();<br>        <span class="hljs-comment">//遍历方法 通过注解 得到需要修复的方法</span><br>        <span class="hljs-keyword">for</span> (Method rightMethod : methods) &#123;<br>            <span class="hljs-comment">//拿到注解</span><br>            <span class="hljs-type">Replace</span> <span class="hljs-variable">replace</span> <span class="hljs-operator">=</span> rightMethod.getAnnotation(Replace.class);<br>            <span class="hljs-keyword">if</span> (replace == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-comment">//得到类名</span><br>            String clazzName=replace.clazz();<br>            <span class="hljs-comment">//得到方法名</span><br>            String methodName=replace.method();<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">//反射得到本地的有bug的方法的类</span><br>                Class wrongClazz=  Class.forName(clazzName);<br>                <span class="hljs-comment">//得到有bug的方法（注意修复包中的方法参数名和参数列表必须一致）</span><br>                <span class="hljs-type">Method</span> <span class="hljs-variable">wrongMethod</span> <span class="hljs-operator">=</span> wrongClazz.getDeclaredMethod(methodName, rightMethod.getParameterTypes());<br>                <span class="hljs-comment">//调用native方法替换有bug的方法</span><br>                replace(wrongMethod, rightMethod);<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br><br><br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">replace</span><span class="hljs-params">(Method wrongMethod, Method rightMethod)</span> ;<br>&#125;<br><br></code></pre></td></tr></table></figure></li></ul><h4 id="实现Native方法替换"><a href="#实现Native方法替换" class="headerlink" title="实现Native方法替换"></a>实现Native方法替换</h4><p>   我们前面说了，方法在虚拟机中是以<code>ArtMethod</code>结构体存在的，那么我们替换就是要去替换旧的方法的<code>ArtMethod</code>对象的所有属性。</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs xl">#include &lt;jni.h&gt;<br>#include &lt;string&gt;<br>#include <span class="hljs-string">&quot;art_method.h&quot;</span><br><br>extern <span class="hljs-string">&quot;C&quot;</span><br>JNIEXPORT void JNICALL<br>Java_com_example_bthvi_mycloassloaderapplication_FixDexManager_replace(JNIEnv *env, jclass type, jobject wrongMethod,<br>                                             jobject rightMethod) &#123;<br><br>    <span class="hljs-comment">//ArtMethod存在于Android 系统源码中，只需要导入我们需要的部分（art_method.h）</span><br>    <span class="hljs-function"><span class="hljs-title">art</span>::mirror::ArtMethod *wrong=  (art::mirror::ArtMethod *)env-&gt;</span>FromReflectedMethod(wrongMethod);<br>    <span class="hljs-function"><span class="hljs-title">art</span>::mirror::ArtMethod *right=  (art::mirror::ArtMethod *)env-&gt;</span>FromReflectedMethod(rightMethod);<br>    <span class="hljs-comment">//    method   ---&gt;class ----被加载---&gt;ClassLoader</span><br>    <span class="hljs-comment">//错误的成员变量替换为正确的成员变量</span><br>    <span class="hljs-function"><span class="hljs-title">wrong</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">declaring_class_</span> = right-&gt;</span>declaring_class_;<br>    <span class="hljs-function"><span class="hljs-title">wrong</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">dex_cache_resolved_methods_</span> = right-&gt;</span>dex_cache_resolved_methods_;<br>    <span class="hljs-function"><span class="hljs-title">wrong</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">access_flags_</span> = right-&gt;</span>access_flags_;<br>    <span class="hljs-function"><span class="hljs-title">wrong</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">dex_cache_resolved_types_</span> = right-&gt;</span>dex_cache_resolved_types_;<br>    <span class="hljs-function"><span class="hljs-title">wrong</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">dex_code_item_offset_</span> = right-&gt;</span>dex_code_item_offset_;<br>    <span class="hljs-comment">//    这里   方法索引的替换</span><br>    <span class="hljs-function"><span class="hljs-title">wrong</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">method_index_</span> = right-&gt;</span>method_index_;<br>    <span class="hljs-function"><span class="hljs-title">wrong</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">dex_method_index_</span> = right-&gt;</span>dex_method_index_;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>这里由于要用到<code>ArtMethod</code>所以我们要从源码中拿到<code>ArtMethod</code>,源码中<code>ArtMethod</code>引用太多的系统源码我们这里简化一下，只要声明我们需要的变量即可。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">namespace</span> <span class="hljs-symbol">art</span> &#123;<br>    <span class="hljs-keyword">namespace</span> <span class="hljs-symbol">mirror</span> &#123;<br>        <span class="hljs-keyword">class</span> <span class="hljs-symbol">Object</span>&#123;<br>            <span class="hljs-comment">// The Class representing the type of the object.</span><br>            <span class="hljs-built_in">uint32</span>_t klass_;<br>            <span class="hljs-comment">// Monitor and hash code information.</span><br>            <span class="hljs-built_in">uint32</span>_t monitor_;<br><br>        &#125;;<br>        <span class="hljs-comment">//简化ArtMethod  只需要关注我们需要的，只需要成员变量声明</span><br>        <span class="hljs-keyword">class</span> <span class="hljs-symbol">ArtMethod</span> : <span class="hljs-symbol">public</span> <span class="hljs-symbol">Object</span> &#123;<br>        <span class="hljs-keyword">public</span>:<br><br>            <span class="hljs-built_in">uint32</span>_t access_flags_;<br>            <span class="hljs-built_in">uint32</span>_t dex_code_item_offset_;<br>            <span class="hljs-comment">// Index into method_ids of the dex file associated with this method</span><br>            <span class="hljs-comment">//方法再dex中的索引</span><br>            <span class="hljs-built_in">uint32</span>_t method_dex_index_;<br>            <span class="hljs-built_in">uint32</span>_t dex_method_index_;<br>            <span class="hljs-comment">//在方法表的索引</span><br>            <span class="hljs-built_in">uint32</span>_t method_index_;<br>            <span class="hljs-keyword">const</span> <span class="hljs-built_in">void</span> *native_method_;<br><br>            <span class="hljs-keyword">const</span> <span class="hljs-built_in">uint16</span>_t *vmap_table_;<br>            <span class="hljs-comment">// Short cuts to declaring_class_-&gt;dex_cache_ member for fast compiled code access.</span><br>            <span class="hljs-built_in">uint32</span>_t dex_cache_resolved_methods_;<br>            <span class="hljs-comment">//方法 自发</span><br>            <span class="hljs-comment">// Short cuts to declaring_class_-&gt;dex_cache_ member for fast compiled code access.</span><br>            <span class="hljs-built_in">uint32</span>_t dex_cache_resolved_types_;<br><br><br>            <span class="hljs-comment">// Field order required by test &quot;ValidateFieldOrderOfJavaCppUnionClasses&quot;.</span><br>            <span class="hljs-comment">// The class we are a part of.</span><br>            <span class="hljs-comment">//所属的函数</span><br>            <span class="hljs-built_in">uint32</span>_t declaring_class_;<br>        &#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里还用到了<code>Object</code>所以我们还是要声明<code>Object</code>这个的源码太多这里就不复制了，我们也不需要特意去搞懂这些底层源码，只需要关注我们需要的就行。到这里我们就实现了Native层的热修复。</p><h2 id="Andfix的兼容性"><a href="#Andfix的兼容性" class="headerlink" title="Andfix的兼容性"></a>Andfix的兼容性</h2><p>前面我们说的就是Andfix的原理及简单实现，但是<font color="red"><strong>Andfix兼容性比较差</strong></font>。它的兼容性差是为什么呢？我们这里主要的原理是替换<code>ArtMethod</code>结构体的成员变量，这个结构体是初始化方法表时虚拟机创建的，<font color="red">Google对于不同的系统版本<code>ArtMethod</code>结构体的成员变量都有做变动</font>如下：我们看下Android 6.0和7.0中<code>ArtMethod</code>的不同点[简单找一两个]。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-comment">//  Android 6.0系统源码中ArtMethod 精简版  去掉注释</span><br><span class="hljs-keyword">class</span> <span class="hljs-symbol">ArtMethod</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">uint32</span>_t declaring_class_;<br>    <span class="hljs-built_in">uint32</span>_t dex_cache_resolved_methods_;<br>    <span class="hljs-built_in">uint32</span>_t dex_cache_resolved_types_;<br>    <span class="hljs-built_in">uint32</span>_t access_flags_;<br>    <span class="hljs-built_in">uint32</span>_t dex_code_item_offset_;<br>    <span class="hljs-built_in">uint32</span>_t dex_method_index_;<br>    <span class="hljs-built_in">uint32</span>_t method_index_;<br><br>    struct PtrSizedFields &#123;<br>        <span class="hljs-comment">// Method dispatch from the interpreter invokes this pointer which may cause a bridge into</span><br>        <span class="hljs-comment">// compiled code.</span><br>        <span class="hljs-built_in">void</span>* entry_point_from_interpreter_;<br>        <span class="hljs-comment">// Pointer to JNI function registered to this method, or a function to resolve the JNI function.</span><br>        <span class="hljs-built_in">void</span>* entry_point_from_jni_;<br>        <span class="hljs-comment">// Method dispatch from quick compiled code invokes this pointer which may cause bridging into</span><br>        <span class="hljs-comment">// the interpreter.</span><br>        <span class="hljs-built_in">void</span>* entry_point_from_quick_compiled_code_;<br>    &#125; ptr_sized_fields_;<br>&#125;;<br><br><span class="hljs-comment">//  Android 7.0系统源码中ArtMethod 精简版  去掉注释</span><br><span class="hljs-keyword">class</span> <span class="hljs-symbol">ArtMethod</span> &#123;<br><span class="hljs-keyword">public</span>:<br><br><span class="hljs-built_in">uint32</span>_t declaring_class_;<br><span class="hljs-built_in">uint32</span>_t access_flags_;<br><span class="hljs-built_in">uint32</span>_t dex_code_item_offset_;<br><span class="hljs-built_in">uint32</span>_t dex_method_index_;<br><span class="hljs-built_in">uint16</span>_t method_index_;<br><span class="hljs-built_in">uint16</span>_t hotness_count_;<br>struct PtrSizedFields &#123;<br><span class="hljs-comment">// Short cuts to declaring_class_-&gt;dex_cache_ member for fast compiled code access.</span><br>ArtMethod** dex_cache_resolved_methods_;<br><br><span class="hljs-comment">// Short cuts to declaring_class_-&gt;dex_cache_ member for fast compiled code access.</span><br><span class="hljs-built_in">void</span>* dex_cache_resolved_types_;<br><br><span class="hljs-comment">// Pointer to JNI function registered to this method, or a function to resolve the JNI function,</span><br><span class="hljs-comment">// or the profiling data for non-native methods, or an ImtConflictTable.</span><br><span class="hljs-built_in">void</span>* entry_point_from_jni_;<br><br><span class="hljs-comment">// Method dispatch from quick compiled code invokes this pointer which may cause bridging into</span><br><span class="hljs-comment">// the interpreter.</span><br><span class="hljs-built_in">void</span>* entry_point_from_quick_compiled_code_;<br>&#125; ptr_sized_fields_;<br><br>&#125;;<br></code></pre></td></tr></table></figure><p>从上面的源码中我们明显看到<code>ArtMethod</code>结构体中成员变量的改变，如<code>method_index_</code>在6.0是32位在7.0中就是16位了。还有<code>PtrSizedFields</code>结构体的成员变量也有修改。所以这就使的AndFix的兼容性很差，要想兼容所有版本就得对不同版本去做兼容适配。<br>由于AndFix的兼容性和它是免费开源的,阿里在sophix出来之后就以及不再维护AndFix了。<code>Sophix</code>它的方案可以说是比较完美了，它是结合了JAVA层和Native层的两者的有点，它的原理介绍大家可以看看这本书：<a href="https://yq.aliyun.com/go/articleRenderRedirect?spm=a2c4e.11153940.0.0.7cab7c4eZ9k2ok&url=https://yq.aliyun.com/attachment/download/?id=1855">《深入探索Android热修复技术原理》</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们这里是对它的热修复原理的学习。最后附上项目链接</p><ul><li><a href="https://github.com/Terrybthvi/my_classloader_demo">GitHub:JAVA层实现热修复和Native层实现热修复源码</a></li><li><a href="https://github.com/alibaba/AndFix">GitHub:AndFix开源项目地址</a></li></ul><blockquote><p>欢迎在评论区留下你的观点大家一起交流，一起成长。如果今天的这篇文章对你在工作和生活有所帮助，欢迎<font color="green"><strong>转发</strong></font>分享给更多人。<br></p><p>同时欢迎大家<font color="green"><strong>扫描下方的二维码关注我的公众号</strong></font>大家一起学习交流 Android、HarmonyOS等知识。从这里出发我们一起讨论，一起交流，一起提升。</p></blockquote><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9Wek56NExhdFFNM2czcEI2aFVKODRYRmwxTnFPWlM1ZGJ1NWlhbzJGSzd1TFhqOGdlMDlha2RNWXhpYTZyZFdXbDRENHZGaWEyaWFVQjZpYWU2aWFxUjY5dlM0Zy82NDA?x-oss-process=image/format,png" alt="我的公众号"></p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>热修复</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android热修复——手把手教你实现Android热修复</title>
    <link href="/android/Android%E7%83%AD%E4%BF%AE%E5%A4%8D%E2%80%94%E2%80%94%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E5%AE%9E%E7%8E%B0Android%E7%83%AD%E4%BF%AE%E5%A4%8D/"/>
    <url>/android/Android%E7%83%AD%E4%BF%AE%E5%A4%8D%E2%80%94%E2%80%94%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E5%AE%9E%E7%8E%B0Android%E7%83%AD%E4%BF%AE%E5%A4%8D/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近一段时间看了一些关于Android热修复的知识，比如Andfix,Tinker,Sophix等，看了这些框架的原理，就想着自己能不能手撸一个简单的demo。下面我们就来自己动手实现Android热修复吧。</p><h2 id="热修复实现原理"><a href="#热修复实现原理" class="headerlink" title="热修复实现原理"></a>热修复实现原理</h2><p>   所谓热修复就是，在我们应用上线后出现小bug需要及时修复时，不用再发新的安装包，只需要发布补丁包，在客户不知不觉之间修复掉bug，JAVA虚拟机JVM在运行时，加载的是.classes的字节码文件。而Android也有自己的虚拟机Dalvik&#x2F;ART虚拟机，不过他们加载的是dex文件，但是他们的工作原理都一样，都是经过ClassLoader类加载器。Android在ClassLoader的基础上又定义类PathClassLoader和DexClassLoader，两者都继承自BaseDexClassLoader，下面我们看下他们间的区别：</p><ul><li><code>BaseDexClassLoader</code>源代码位于<code>libcore\dalvik\src\main\java\dalvik\system\BaseDexClassLoader.java</code>。</li><li><code>PathClassLoader</code>源代码位于<code>libcore\dalvik\src\main\Java\dalvik\system\PathClassLoader.java </code>。他主要用来加载系统类和应用类。</li><li><code>DexClassLoader</code>源代码位于<code>libcore\dalvik\src\main\java\dalvik\system\DexClassLoader.java</code>。用来加载jar、apk、dex文件.加载jar、apk也是最终抽取里面的Dex文件进行加载.<br>   <img src="/android/Android%E7%83%AD%E4%BF%AE%E5%A4%8D%E2%80%94%E2%80%94%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E5%AE%9E%E7%8E%B0Android%E7%83%AD%E4%BF%AE%E5%A4%8D/img1.jpg" alt="ClassLoader"><br>Android热修复目前各大厂商都有自己的热修复工具，主要分为两大主流以阿里为代表的<strong>Native层</strong>替换方法表中的方法实现热修复［AndFix ,Sophix等］,和以腾讯美团为代表的在<strong>JAVA层</strong>实现热修复[Tinker，Robust等]。后者要实现热修复必须要重启APP，而前者则不需要重启APP，直接在虚拟机的方法区实现方法替换。<br><font color="red">本文主要实现的是在JAVA层实现热修复，也就是重启APP才能生效。关于Native层实现热修复有兴趣的可以看我的另一篇文章：<a href="../Android%E7%83%AD%E4%BF%AE%E5%A4%8D%E2%80%94%E2%80%94%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E5%AE%9E%E7%8E%B0AndFix%E7%83%AD%E4%BF%AE%E5%A4%8D"><br>Android热修复——手把手教你实现Andfix热修复</a></font></li></ul><h2 id="手写Android热修复框架"><a href="#手写Android热修复框架" class="headerlink" title="手写Android热修复框架"></a>手写Android热修复框架</h2><p>下面我们一步一步来实现Android热修复。</p><h3 id="写一个专门带有bug的类"><a href="#写一个专门带有bug的类" class="headerlink" title="写一个专门带有bug的类"></a>写一个专门带有bug的类</h3><p>既然要测试热修复，我们肯定要写一个带有bug的类。</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">package com.example.<span class="hljs-keyword">bthvi.mycloassloaderapplication.xxx;</span><br><span class="hljs-keyword"></span><br>import <span class="hljs-keyword">android.content.Context;</span><br><span class="hljs-keyword"></span>import <span class="hljs-keyword">android.view.View;</span><br><span class="hljs-keyword"></span>import <span class="hljs-keyword">android.widget.Toast;</span><br><span class="hljs-keyword"></span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * bug测试类</span><br><span class="hljs-comment"> */</span><br>public class <span class="hljs-keyword">BugClass </span>&#123;<br><br>    public <span class="hljs-keyword">BugClass(Context </span><span class="hljs-built_in">context</span>)&#123;<br>        Toast.makeText(<span class="hljs-built_in">context</span>,<span class="hljs-string">&quot;这是一个优美的bug！&quot;</span>,Toast.LENGTH_SHORT).<span class="hljs-keyword">show();</span><br><span class="hljs-keyword"></span>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>下面我们要写一个热修复的核心工具类。</p><h3 id="热修复核心类"><a href="#热修复核心类" class="headerlink" title="热修复核心类"></a>热修复核心类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.example.bthvi.mycloassloaderapplication;<br><br><span class="hljs-keyword">import</span> android.content.Context;<br><span class="hljs-keyword">import</span> android.os.Environment;<br><span class="hljs-keyword">import</span> android.support.annotation.NonNull;<br><span class="hljs-keyword">import</span> android.widget.Toast;<br><br><span class="hljs-keyword">import</span> java.io.File;<br><span class="hljs-keyword">import</span> java.lang.reflect.Array;<br><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><span class="hljs-keyword">import</span> java.util.HashSet;<br><br><span class="hljs-keyword">import</span> dalvik.system.DexClassLoader;<br><span class="hljs-keyword">import</span> dalvik.system.PathClassLoader;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FixDexUtil</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">DEX_SUFFIX</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;.dex&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">APK_SUFFIX</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;.apk&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">JAR_SUFFIX</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;.jar&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">ZIP_SUFFIX</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;.zip&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">DEX_DIR</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;odex&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">OPTIMIZE_DEX_DIR</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;optimize_dex&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> HashSet&lt;File&gt; loadedDex = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        loadedDex.clear();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 加载补丁，使用默认目录：data/data/包名/files/odex</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> context</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">loadFixedDex</span><span class="hljs-params">(Context context)</span> &#123;<br>        loadFixedDex(context, <span class="hljs-literal">null</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 加载补丁</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> context       上下文</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> patchFilesDir 补丁所在目录</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">loadFixedDex</span><span class="hljs-params">(Context context, File patchFilesDir)</span> &#123;<br>        <span class="hljs-comment">// dex合并之前的dex</span><br>        doDexInject(context, loadedDex);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     *<span class="hljs-doctag">@author</span> bthvi</span><br><span class="hljs-comment">     *<span class="hljs-doctag">@time</span> 2018/6/25 0025 15:51</span><br><span class="hljs-comment">     *<span class="hljs-doctag">@desc</span> 验证是否需要热修复</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isGoingToFix</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Context context)</span> &#123;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">canFix</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">File</span> <span class="hljs-variable">externalStorageDirectory</span> <span class="hljs-operator">=</span> Environment.getExternalStorageDirectory();<br><br>        <span class="hljs-comment">// 遍历所有的修复dex , 因为可能是多个dex修复包</span><br>        <span class="hljs-type">File</span> <span class="hljs-variable">fileDir</span> <span class="hljs-operator">=</span> externalStorageDirectory != <span class="hljs-literal">null</span> ?<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(externalStorageDirectory,<span class="hljs-string">&quot;007&quot;</span>):<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(context.getFilesDir(), DEX_DIR);<span class="hljs-comment">// data/data/包名/files/odex（这个可以任意位置）</span><br><br>        File[] listFiles = fileDir.listFiles();<br>        <span class="hljs-keyword">if</span> (listFiles != <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">for</span> (File file : listFiles) &#123;<br>                <span class="hljs-keyword">if</span> (file.getName().startsWith(<span class="hljs-string">&quot;classes&quot;</span>) &amp;&amp;<br>                        (file.getName().endsWith(DEX_SUFFIX)<br>                                || file.getName().endsWith(APK_SUFFIX)<br>                                || file.getName().endsWith(JAR_SUFFIX)<br>                                || file.getName().endsWith(ZIP_SUFFIX))) &#123;<br><br>                    loadedDex.add(file);<span class="hljs-comment">// 存入集合</span><br>                    <span class="hljs-comment">//有目标dex文件, 需要修复</span><br>                    canFix = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> canFix;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doDexInject</span><span class="hljs-params">(Context appContext, HashSet&lt;File&gt; loadedDex)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">optimizeDir</span> <span class="hljs-operator">=</span> appContext.getFilesDir().getAbsolutePath() +<br>                File.separator + OPTIMIZE_DEX_DIR;<br>        <span class="hljs-comment">// data/data/包名/files/optimize_dex（这个必须是自己程序下的目录）</span><br><br>        <span class="hljs-type">File</span> <span class="hljs-variable">fopt</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(optimizeDir);<br>        <span class="hljs-keyword">if</span> (!fopt.exists()) &#123;<br>            fopt.mkdirs();<br>        &#125;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 1.加载应用程序dex的Loader</span><br>            <span class="hljs-type">PathClassLoader</span> <span class="hljs-variable">pathLoader</span> <span class="hljs-operator">=</span> (PathClassLoader) appContext.getClassLoader();<br>            <span class="hljs-keyword">for</span> (File dex : loadedDex) &#123;<br>                <span class="hljs-comment">// 2.加载指定的修复的dex文件的Loader</span><br>                <span class="hljs-type">DexClassLoader</span> <span class="hljs-variable">dexLoader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DexClassLoader</span>(<br>                        dex.getAbsolutePath(),<span class="hljs-comment">// 修复好的dex（补丁）所在目录</span><br>                        fopt.getAbsolutePath(),<span class="hljs-comment">// 存放dex的解压目录（用于jar、zip、apk格式的补丁）</span><br>                        <span class="hljs-literal">null</span>,<span class="hljs-comment">// 加载dex时需要的库</span><br>                        pathLoader<span class="hljs-comment">// 父类加载器</span><br>                );<br>                <span class="hljs-comment">// 3.开始合并</span><br>                <span class="hljs-comment">// 合并的目标是Element[],重新赋值它的值即可</span><br><br>                <span class="hljs-comment">/**</span><br><span class="hljs-comment">                 * BaseDexClassLoader中有 变量: DexPathList pathList</span><br><span class="hljs-comment">                 * DexPathList中有 变量 Element[] dexElements</span><br><span class="hljs-comment">                 * 依次反射即可</span><br><span class="hljs-comment">                 */</span><br><br>                <span class="hljs-comment">//3.1 准备好pathList的引用</span><br>                <span class="hljs-type">Object</span> <span class="hljs-variable">dexPathList</span> <span class="hljs-operator">=</span> getPathList(dexLoader);<br>                <span class="hljs-type">Object</span> <span class="hljs-variable">pathPathList</span> <span class="hljs-operator">=</span> getPathList(pathLoader);<br>                <span class="hljs-comment">//3.2 从pathList中反射出element集合</span><br>                <span class="hljs-type">Object</span> <span class="hljs-variable">leftDexElements</span> <span class="hljs-operator">=</span> getDexElements(dexPathList);<br>                <span class="hljs-type">Object</span> <span class="hljs-variable">rightDexElements</span> <span class="hljs-operator">=</span> getDexElements(pathPathList);<br>                <span class="hljs-comment">//3.3 合并两个dex数组</span><br>                <span class="hljs-type">Object</span> <span class="hljs-variable">dexElements</span> <span class="hljs-operator">=</span> combineArray(leftDexElements, rightDexElements);<br><br>                <span class="hljs-comment">// 重写给PathList里面的Element[] dexElements;赋值</span><br>                <span class="hljs-type">Object</span> <span class="hljs-variable">pathList</span> <span class="hljs-operator">=</span> getPathList(pathLoader);<span class="hljs-comment">// 一定要重新获取，不要用pathPathList，会报错</span><br>                setField(pathList, pathList.getClass(), <span class="hljs-string">&quot;dexElements&quot;</span>, dexElements);<br>            &#125;<br>            Toast.makeText(appContext, <span class="hljs-string">&quot;修复完成&quot;</span>, Toast.LENGTH_SHORT).show();<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 反射给对象中的属性重新赋值</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setField</span><span class="hljs-params">(Object obj, Class&lt;?&gt; cl, String field, Object value)</span> <span class="hljs-keyword">throws</span> NoSuchFieldException, IllegalAccessException &#123;<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">declaredField</span> <span class="hljs-operator">=</span> cl.getDeclaredField(field);<br>        declaredField.setAccessible(<span class="hljs-literal">true</span>);<br>        declaredField.set(obj, value);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 反射得到对象中的属性值</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">getField</span><span class="hljs-params">(Object obj, Class&lt;?&gt; cl, String field)</span> <span class="hljs-keyword">throws</span> NoSuchFieldException, IllegalAccessException &#123;<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">localField</span> <span class="hljs-operator">=</span> cl.getDeclaredField(field);<br>        localField.setAccessible(<span class="hljs-literal">true</span>);<br>        <span class="hljs-keyword">return</span> localField.get(obj);<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 反射得到类加载器中的pathList对象</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">getPathList</span><span class="hljs-params">(Object baseDexClassLoader)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException, NoSuchFieldException, IllegalAccessException &#123;<br>        <span class="hljs-keyword">return</span> getField(baseDexClassLoader, Class.forName(<span class="hljs-string">&quot;dalvik.system.BaseDexClassLoader&quot;</span>), <span class="hljs-string">&quot;pathList&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 反射得到pathList中的dexElements</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">getDexElements</span><span class="hljs-params">(Object pathList)</span> <span class="hljs-keyword">throws</span> NoSuchFieldException, IllegalAccessException &#123;<br>        <span class="hljs-keyword">return</span> getField(pathList, pathList.getClass(), <span class="hljs-string">&quot;dexElements&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 数组合并</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">combineArray</span><span class="hljs-params">(Object arrayLhs, Object arrayRhs)</span> &#123;<br>        Class&lt;?&gt; clazz = arrayLhs.getClass().getComponentType();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> Array.getLength(arrayLhs);<span class="hljs-comment">// 得到左数组长度（补丁数组）</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> Array.getLength(arrayRhs);<span class="hljs-comment">// 得到原dex数组长度</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> i + j;<span class="hljs-comment">// 得到总数组长度（补丁数组+原dex数组）</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> Array.newInstance(clazz, k);<span class="hljs-comment">// 创建一个类型为clazz，长度为k的新数组</span><br>        System.arraycopy(arrayLhs, <span class="hljs-number">0</span>, result, <span class="hljs-number">0</span>, i);<br>        System.arraycopy(arrayRhs, <span class="hljs-number">0</span>, result, i, j);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>我们这里暂且指定热修复目录<code>007</code>，下面我们看一下如何调用。</p><h3 id="Splash页面调用检查热修复"><a href="#Splash页面调用检查热修复" class="headerlink" title="Splash页面调用检查热修复"></a>Splash页面调用检查热修复</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs csharp">    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span>()</span> &#123;<br>        File externalStorageDirectory = Environment.getExternalStorageDirectory();<br><br>    <span class="hljs-comment">// 遍历所有的修复dex , 因为可能是多个dex修复包</span><br>    File fileDir = externalStorageDirectory != <span class="hljs-literal">null</span> ?<br>            <span class="hljs-keyword">new</span> File(externalStorageDirectory,<span class="hljs-string">&quot;007&quot;</span>):<br>            <span class="hljs-keyword">new</span> File(getFilesDir(), FixDexUtil.DEX_DIR);<span class="hljs-comment">// data/user/0/包名/files/odex（这个可以任意位置）</span><br>        <span class="hljs-keyword">if</span> (!fileDir.exists())&#123;<br>        fileDir.mkdirs();<br>    &#125;<br>        <span class="hljs-keyword">if</span> (FixDexUtil.isGoingToFix(<span class="hljs-keyword">this</span>)) &#123;<br><br>        FixDexUtil.loadFixedDex(<span class="hljs-keyword">this</span>, Environment.getExternalStorageDirectory());<br>        textView.setText(<span class="hljs-string">&quot;正在修复。。。。&quot;</span>);<br><br>    &#125;<br>     <span class="hljs-keyword">new</span> Handler().postDelayed(<span class="hljs-keyword">new</span> Runnable() &#123;<br>        @Override<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span>()</span> &#123;<br>            startActivity(<span class="hljs-keyword">new</span> Intent(SplashActivity.<span class="hljs-keyword">this</span>,MainActivity.<span class="hljs-keyword">class</span>));<br>            finish();<br>        &#125;<br>    &#125;,<span class="hljs-number">3000</span>);<br><br>&#125;<br></code></pre></td></tr></table></figure><p>下面我们先来看下有bug时的APP。<br><img src="/android/Android%E7%83%AD%E4%BF%AE%E5%A4%8D%E2%80%94%E2%80%94%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E5%AE%9E%E7%8E%B0Android%E7%83%AD%E4%BF%AE%E5%A4%8D/img2.png" alt="bug截图"></p><h3 id="在出bug的对应类修复bug"><a href="#在出bug的对应类修复bug" class="headerlink" title="在出bug的对应类修复bug"></a>在出bug的对应类修复bug</h3><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">package com.example.<span class="hljs-keyword">bthvi.mycloassloaderapplication.xxx;</span><br><span class="hljs-keyword"></span><br>import <span class="hljs-keyword">android.content.Context;</span><br><span class="hljs-keyword"></span>import <span class="hljs-keyword">android.view.View;</span><br><span class="hljs-keyword"></span>import <span class="hljs-keyword">android.widget.Toast;</span><br><span class="hljs-keyword"></span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * bug测试类</span><br><span class="hljs-comment"> */</span><br>public class <span class="hljs-keyword">BugClass </span>&#123;<br><br>    public <span class="hljs-keyword">BugClass(Context </span><span class="hljs-built_in">context</span>)&#123;<br>        Toast.makeText(<span class="hljs-built_in">context</span>,<span class="hljs-string">&quot;你很优秀！bug已修复?&quot;</span>,Toast.LENGTH_SHORT).<span class="hljs-keyword">show();</span><br><span class="hljs-keyword"></span>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>修改好bug之后我们需要打出补丁包。</p><h3 id="打出热修复补丁包"><a href="#打出热修复补丁包" class="headerlink" title="打出热修复补丁包"></a>打出热修复补丁包</h3><h4 id="在AndroidStudio里面关闭掉Instant-Run"><a href="#在AndroidStudio里面关闭掉Instant-Run" class="headerlink" title="在AndroidStudio里面关闭掉Instant_Run"></a>在AndroidStudio里面关闭掉Instant_Run</h4><p>由于Android Studio的instan run的原理也是热修复，所以安装的时候不会安装完整的安装包，只会安装新改变的代码。<br><img src="/android/Android%E7%83%AD%E4%BF%AE%E5%A4%8D%E2%80%94%E2%80%94%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E5%AE%9E%E7%8E%B0Android%E7%83%AD%E4%BF%AE%E5%A4%8D/img3.jpg" alt="instant run"></p><h4 id="重新编译并拷贝出新修改的类"><a href="#重新编译并拷贝出新修改的类" class="headerlink" title="重新编译并拷贝出新修改的类"></a>重新编译并拷贝出新修改的类</h4><p>首先点击<code>Build-&gt;RebuildProject</code>来重新构建,构建完成之后,可以在<code>app/build/interintermediate/debug/包名/</code>找到你刚刚修改的class文件,将他拷贝出来,要连同包名路径一起拷贝出来。<br><img src="/android/Android%E7%83%AD%E4%BF%AE%E5%A4%8D%E2%80%94%E2%80%94%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E5%AE%9E%E7%8E%B0Android%E7%83%AD%E4%BF%AE%E5%A4%8D/img4.jpg" alt="RebuildProject"></p><h4 id="将class文件打包成dex文件"><a href="#将class文件打包成dex文件" class="headerlink" title="将class文件打包成dex文件"></a>将class文件打包成dex文件</h4><p>我们前面知道热修复的原理是Dalvik&#x2F;ART加载dex文件，所以接下来我们要将class文件打包成dex文件，首先我们找到AndroidSDK的build-tools 目录下，在控制台下进入该目录下的任意一个版本，执行dx命令，关于dx命令的使用帮助可以使用<code>dx -- help</code>,下面们通过 <code>dx --dex [指定输出路径]/classes.dex  [刚才拷贝的修复bug的类及包名的目录]</code>这样我们就得到了.dex文件。</p><h4 id="将打出来的dex文件放至我们指定的目录下"><a href="#将打出来的dex文件放至我们指定的目录下" class="headerlink" title="将打出来的dex文件放至我们指定的目录下"></a>将打出来的dex文件放至我们指定的目录下</h4><p>我们将打出来的dex文件放在我们指定的目录<code>007</code>下，当然这个目录也可以是包名。<br><img src="/android/Android%E7%83%AD%E4%BF%AE%E5%A4%8D%E2%80%94%E2%80%94%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E5%AE%9E%E7%8E%B0Android%E7%83%AD%E4%BF%AE%E5%A4%8D/img4.png" alt="存储至手机SDK卡"></p><h4 id="重新启动有bug的APP"><a href="#重新启动有bug的APP" class="headerlink" title="重新启动有bug的APP"></a>重新启动有bug的APP</h4><p>我们启动就会后发现bug已经修复了<br><img src="/android/Android%E7%83%AD%E4%BF%AE%E5%A4%8D%E2%80%94%E2%80%94%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E5%AE%9E%E7%8E%B0Android%E7%83%AD%E4%BF%AE%E5%A4%8D/img5.png" alt="修复完成截图"></p><h2 id="没有修复？"><a href="#没有修复？" class="headerlink" title="没有修复？"></a>没有修复？</h2><p><font color="red" size="5">很多同学反馈说没有修复，我觉得主要还是要检查下 isGoingToFix方法，因为这个方法中有一个判断是需要判断目标路径下，修复包的名称一定要为classes开头，以dex结尾</font></p><pre><code class="hljs">           if (file.getName().startsWith(&quot;classes&quot;) &amp;&amp;                    (file.getName().endsWith(DEX_SUFFIX)                            || file.getName().endsWith(APK_SUFFIX)                            || file.getName().endsWith(JAR_SUFFIX)                            || file.getName().endsWith(ZIP_SUFFIX))) &#123;                            &#125;</code></pre><h2 id="其他文章"><a href="#其他文章" class="headerlink" title="其他文章"></a>其他文章</h2><h4 id="1、Gradle"><a href="#1、Gradle" class="headerlink" title="1、Gradle"></a>1、Gradle</h4><p><a href="https://bthvi-leiqi.blog.csdn.net/article/details/52355915">gradle 详解——你真的了解Gradle吗？</a></p><p><a href="https://bthvi-leiqi.blog.csdn.net/article/details/51918534">一分钟帮你提升Android studio 编译速度</a></p><h4 id="2、Flutter"><a href="#2、Flutter" class="headerlink" title="2、Flutter"></a>2、Flutter</h4><p><a href="https://bthvi-leiqi.blog.csdn.net/article/details/80474494">Flutter从入门到实战</a></p><h4 id="3、源码"><a href="#3、源码" class="headerlink" title="3、源码"></a>3、源码</h4><p><a href="https://bthvi-leiqi.blog.csdn.net/article/details/89181005">深入理解HashMap原理(一)——HashMap源码解析(JDK 1.8)</a></p><p><a href="https://bthvi-leiqi.blog.csdn.net/article/details/89354198">深入理解HashMap原理(二)——手写HashMap</a></p><p><a href="https://bthvi-leiqi.blog.csdn.net/article/details/81809890">Handler 源码解析——Handler的创建</a></p><h4 id="4、热修复"><a href="#4、热修复" class="headerlink" title="4、热修复"></a>4、热修复</h4><p> <a href="../Android%E7%83%AD%E4%BF%AE%E5%A4%8D%E2%80%94%E2%80%94%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E5%AE%9E%E7%8E%B0AndFix%E7%83%AD%E4%BF%AE%E5%A4%8D">Android热修复——深入剖析AndFix热修复及自己动手实现</a></p><p> <a href="https://bthvi-leiqi.blog.csdn.net/article/details/95076522">手撸一款Android屏幕适配SDK</a><br> <a href="https://bthvi-leiqi.blog.csdn.net/article/details/80878256">Android自定义无压缩加载超清大图</a></p><blockquote><p>欢迎在评论区留下你的观点大家一起交流，一起成长。如果今天的这篇文章对你在工作和生活有所帮助，欢迎<font color="green"><strong>转发</strong></font>分享给更多人。<br></p><p>同时欢迎大家<font color="green"><strong>扫描下方的二维码关注我的公众号</strong></font>大家一起学习交流 Android、HarmonyOS等知识。从这里出发我们一起讨论，一起交流，一起提升。</p></blockquote><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9Wek56NExhdFFNM2czcEI2aFVKODRYRmwxTnFPWlM1ZGJ1NWlhbzJGSzd1TFhqOGdlMDlha2RNWXhpYTZyZFdXbDRENHZGaWEyaWFVQjZpYWU2aWFxUjY5dlM0Zy82NDA?x-oss-process=image/format,png" alt="我的公众号"></p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>热修复</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>初识HarmonyOS——认识DevEco Studio &amp; HarmonyOS工程结构</title>
    <link href="/harmonyos/%E5%88%9D%E8%AF%86HarmonyOS%E2%80%94%E2%80%94%E8%AE%A4%E8%AF%86DevEco%20Studio%20&amp;%20HarmonyOS%E5%B7%A5%E7%A8%8B%E7%BB%93%E6%9E%84/"/>
    <url>/harmonyos/%E5%88%9D%E8%AF%86HarmonyOS%E2%80%94%E2%80%94%E8%AE%A4%E8%AF%86DevEco%20Studio%20&amp;%20HarmonyOS%E5%B7%A5%E7%A8%8B%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<p>前面一篇文章，我们主要是较大家，从下载 IDE、搭建环境，再到将一个简单的Hello World 程序部署在模拟器上。这一篇我们主要来认识 DevEco Studio 和 HarmonyOS 工程的目录结构，以及各目录的作用。</p><h2 id="DevEco-Studio-配置界面"><a href="#DevEco-Studio-配置界面" class="headerlink" title="DevEco Studio 配置界面"></a>DevEco Studio 配置界面</h2><p>进入IDE后，我们首先了解一下基础的界面。整个IDE的界面和 Android Studio 非常的像， 大致上可以分为四个部分，分别是<br>代码编辑区、通知栏&amp;日志信息展示区、工程目录区 以及 UI预览区。</p><p><img src="/harmonyos/%E5%88%9D%E8%AF%86HarmonyOS%E2%80%94%E2%80%94%E8%AE%A4%E8%AF%86DevEco%20Studio%20&%20HarmonyOS%E5%B7%A5%E7%A8%8B%E7%BB%93%E6%9E%84/Image.png" alt="HarmonyOS"></p><ul><li><p>工程目录区<br>  IDE 左侧为工程目录区，后续章节会详细介绍。<br><img src="/harmonyos/%E5%88%9D%E8%AF%86HarmonyOS%E2%80%94%E2%80%94%E8%AE%A4%E8%AF%86DevEco%20Studio%20&%20HarmonyOS%E5%B7%A5%E7%A8%8B%E7%BB%93%E6%9E%84/Image%20%5B1%5D.png" alt="HarmonyOS"></p></li><li><p><strong>代码编辑区</strong><br>  中间的是代码编辑区，你可以在这里修改你的代码，以及切换显示的文件。通过按住Ctrl加鼠标滚轮，可以实现界面的放大与缩小。</p></li><li><p><strong>通知栏&amp;日志信息展示区</strong><br>在编辑器底部有一行工具栏，主要介绍常用信息栏，</p><ul><li><strong>Run</strong>: 是项目运行时的信息栏，</li><li><strong>Problems</strong>: 是当前工程错误与提醒信息栏，</li><li><strong>Terminal</strong>: 是命令行终端，在这里执行命令行操作，</li><li><strong>PreviewerLog</strong>: 是预览器日志输出栏，</li><li><strong>Log</strong>: 是模拟器和真机运行时的日志输出栏。在后续使用中会陆续接触。<br><img src="/harmonyos/%E5%88%9D%E8%AF%86HarmonyOS%E2%80%94%E2%80%94%E8%AE%A4%E8%AF%86DevEco%20Studio%20&%20HarmonyOS%E5%B7%A5%E7%A8%8B%E7%BB%93%E6%9E%84/Image%20%5B2%5D.png" alt="HarmonyOS"></li></ul></li><li><p><strong>UI预览区</strong><br>  点击右上角 <code>Previewer</code>, 可以预览对应的文件UI展示效果。如果是非UI页面点击后会出现预览界面，一定要在UI 文件点击。<br><img src="/harmonyos/%E5%88%9D%E8%AF%86HarmonyOS%E2%80%94%E2%80%94%E8%AE%A4%E8%AF%86DevEco%20Studio%20&%20HarmonyOS%E5%B7%A5%E7%A8%8B%E7%BB%93%E6%9E%84/Image%20%5B3%5D.png" alt="HarmonyOS"><br>此外 DevEco Studio 还提供了一些基本功能，包括旋转屏幕，切换显示设备及多设备预览等。单击旋转按钮，可以切换竖屏和横屏显示的效果。<br><img src="/harmonyos/%E5%88%9D%E8%AF%86HarmonyOS%E2%80%94%E2%80%94%E8%AE%A4%E8%AF%86DevEco%20Studio%20&%20HarmonyOS%E5%B7%A5%E7%A8%8B%E7%BB%93%E6%9E%84/Image%20%5B4%5D.png" alt="HarmonyOS"><br>也可以单击如下列表按钮，切换显示的设备类型。弹出框内会显示 <code>Available Profiles</code>，即可用的设备类型。<br><img src="/harmonyos/%E5%88%9D%E8%AF%86HarmonyOS%E2%80%94%E2%80%94%E8%AE%A4%E8%AF%86DevEco%20Studio%20&%20HarmonyOS%E5%B7%A5%E7%A8%8B%E7%BB%93%E6%9E%84/Image%20%5B5%5D.png" alt="HarmonyOS"><br>如单击 <code>Foldable</code> 切换设备，也可以单击旋转按钮切换 <code>Foldable</code> 的横竖屏显示模式。</p></li></ul><p>打开 <code>Muti-profile preview</code> 开关，可以实现多个尺寸设备的实时预览。<br><img src="/harmonyos/%E5%88%9D%E8%AF%86HarmonyOS%E2%80%94%E2%80%94%E8%AE%A4%E8%AF%86DevEco%20Studio%20&%20HarmonyOS%E5%B7%A5%E7%A8%8B%E7%BB%93%E6%9E%84/Image%20%5B6%5D.png" alt="HarmonyOS"><br>单击预览器右上角组件预览按钮，可以进入组件预览界面。<br><img src="/harmonyos/%E5%88%9D%E8%AF%86HarmonyOS%E2%80%94%E2%80%94%E8%AE%A4%E8%AF%86DevEco%20Studio%20&%20HarmonyOS%E5%B7%A5%E7%A8%8B%E7%BB%93%E6%9E%84/Image%20%5B7%5D.png" alt="HarmonyOS"><br>组件预览模式可以预览当前组件对应的代码块。</p><p>点击相应组件，代码文件中会框选对应的组件代码部分，下方则对应当前组件的基本属性。</p><p><img src="/harmonyos/%E5%88%9D%E8%AF%86HarmonyOS%E2%80%94%E2%80%94%E8%AE%A4%E8%AF%86DevEco%20Studio%20&%20HarmonyOS%E5%B7%A5%E7%A8%8B%E7%BB%93%E6%9E%84/Image%20%5B8%5D.png" alt="HarmonyOS"></p><h2 id="了解工程目录结构"><a href="#了解工程目录结构" class="headerlink" title="了解工程目录结构"></a>了解工程目录结构</h2><h3 id="根目录（工程级目录）"><a href="#根目录（工程级目录）" class="headerlink" title="根目录（工程级目录）"></a>根目录（工程级目录）</h3><p><img src="/harmonyos/%E5%88%9D%E8%AF%86HarmonyOS%E2%80%94%E2%80%94%E8%AE%A4%E8%AF%86DevEco%20Studio%20&%20HarmonyOS%E5%B7%A5%E7%A8%8B%E7%BB%93%E6%9E%84/Image%20%5B9%5D.png" alt="HarmonyOS"><br>工程的目录结构如上图，其中详细如下：</p><ul><li><strong>AppScope</strong>：中存放应用全局所需要的资源文件。</li><li><strong>entry</strong>：是应用的主模块，存放HarmonyOS应用的代码、资源等。</li><li><strong>oh_modules</strong>：是工程的依赖包，存放工程依赖的源文件。</li><li><strong>build-profile.json5</strong>：是工程级配置信息，包括签名、产品配置等。</li><li><strong>hvigorfile.ts</strong>：是工程级编译构建任务脚本，hvigor是基于任务管理机制实现的一款全新的自动化构建工具，主要提供任务注册编排，工程模型管理、配置管理等核心能力。</li><li><strong>oh-package.json5</strong>：是工程级依赖配置文件，用于记录引入包的配置信息。</li></ul><p>在 <code>AppScope</code>，其中有 <code>resources</code> 文件夹和配置文件 <code>app.json5</code>。<code>AppScope&gt;resources&gt;base</code> 中包含 <code>element</code> 和 <code>media</code> 两个文件夹，</p><ul><li><strong>element</strong>: 文件夹主要存放公共的字符串、布局文件等资源。</li><li><strong>media</strong>: 存放全局公共的多媒体资源文件。<br><img src="/harmonyos/%E5%88%9D%E8%AF%86HarmonyOS%E2%80%94%E2%80%94%E8%AE%A4%E8%AF%86DevEco%20Studio%20&%20HarmonyOS%E5%B7%A5%E7%A8%8B%E7%BB%93%E6%9E%84/Image%20%5B10%5D.png" alt="HarmonyOS"></li></ul><h3 id="模块级目录"><a href="#模块级目录" class="headerlink" title="模块级目录"></a>模块级目录</h3><p><img src="/harmonyos/%E5%88%9D%E8%AF%86HarmonyOS%E2%80%94%E2%80%94%E8%AE%A4%E8%AF%86DevEco%20Studio%20&%20HarmonyOS%E5%B7%A5%E7%A8%8B%E7%BB%93%E6%9E%84/Image%20%5B11%5D.png" alt="HarmonyOS"><br><code>entry&gt;src</code> 目录中主要包含总的 <code>main</code> 文件夹，单元测试目录 <code>ohosTest</code> ，以及模块级的配置文件。</p><ul><li>main文件夹中，<ul><li>ets文件夹用于存放ets代码</li><li>resources文件存放模块内的多媒体及布局文件等</li><li>module.json5文件为模块的配置文件</li></ul></li><li>ohosTest是单元测试目录。</li><li>build-profile.json5是模块级配置信息，包括编译构建配置项。</li><li>hvigorfile.ts文件是模块级构建脚本。</li><li>oh-package.json5是模块级依赖配置信息文件。</li></ul><ol><li>进入 <code>src&gt;main&gt;ets</code> 目录中，其分为 <code>entryability</code>、<code>pages</code> 两个文件夹。<br><img src="/harmonyos/%E5%88%9D%E8%AF%86HarmonyOS%E2%80%94%E2%80%94%E8%AE%A4%E8%AF%86DevEco%20Studio%20&%20HarmonyOS%E5%B7%A5%E7%A8%8B%E7%BB%93%E6%9E%84/Image%20%5B12%5D.png" alt="HarmonyOS"></li></ol><ul><li>entryability 存放 ability 文件[关于 ability 我们后面介绍]，用于当前 ability 应用逻辑和生命周期管理。</li><li>pages 存放 UI 界面相关代码文件，初始会生成一个 Index 页面。</li></ul><ol start="2"><li>resources 目录下存放模块公共的多媒体、字符串及布局文件等资源，分别存放在 element、media 文件夹中。<br><img src="/harmonyos/%E5%88%9D%E8%AF%86HarmonyOS%E2%80%94%E2%80%94%E8%AE%A4%E8%AF%86DevEco%20Studio%20&%20HarmonyOS%E5%B7%A5%E7%A8%8B%E7%BB%93%E6%9E%84/Image%20%5B13%5D.png" alt="HarmonyOS"></li></ol><h3 id="app-json5"><a href="#app-json5" class="headerlink" title="app.json5"></a>app.json5</h3><p><code>AppScope&gt;app.json5</code> 是应用的全局的配置文件，用于存放应用公共的配置信息。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;app&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;bundleName&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;com.example.myapplication&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-comment">//包名</span><br>    <span class="hljs-attr">&quot;vendor&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;example&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-comment">//应用长须供应商</span><br>    <span class="hljs-attr">&quot;versionCode&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1000000</span><span class="hljs-punctuation">,</span><span class="hljs-comment">//区分应用版本</span><br>    <span class="hljs-attr">&quot;versionName&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;1.0.0&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-comment">//版本号</span><br>    <span class="hljs-attr">&quot;icon&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;$media:app_icon&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-comment">//应用在桌面显示的图标</span><br>    <span class="hljs-attr">&quot;label&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;$string:app_name&quot;</span><span class="hljs-comment">//应用名称</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="module-json5"><a href="#module-json5" class="headerlink" title="module.json5"></a>module.json5</h3><p><code>entry&gt;src&gt;main&gt;module.json5</code>是模块的配置文件，包含当前模块的配置信息。</p><p>其中 <code>module</code> 对应的是模块的配置信息，一个模块对应一个打包后的 hap 包，hap 包全称是 <code>HarmonyOS Ability Package</code>，其中包含了 ability、第三方库、资源和配置文件。其具体属性及其描述可以参照如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs json"><br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;module&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;entry&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-comment">//该标签标识当前module的名字，module打包成hap后，表示hap的名称，标签值采用字符串表示（最大长度31个字节），该名称在整个应用要唯一。</span><br>    <br>    <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;entry&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-comment">//表示模块的类型，类型有三种，分别是entry、feature和har。</span><br>    <br>    <span class="hljs-attr">&quot;description&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;$string:module_desc&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-comment">//当前模块的描述信息。</span><br>    <br>    <span class="hljs-attr">&quot;mainElement&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;EntryAbility&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-comment">//该标签标识hap的入口ability名称或者extension名称。只有配置为mainElement的ability或者extension才允许在服务中心露出。</span><br>    <br>    <span class="hljs-attr">&quot;deviceTypes&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-comment">//该标签标识hap可以运行在哪类设备上，标签值采用字符串数组的表示。</span><br>      <span class="hljs-string">&quot;phone&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-string">&quot;tablet&quot;</span><br>    <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>    <br>    <span class="hljs-attr">&quot;deliveryWithInstall&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span> <span class="hljs-comment">//标识当前Module是否在用户主动安装的时候安装，表示该Module对应的HAP是否跟随应用一起安装。- true：主动安装时安装。- false：主动安装时不安装。</span><br>    <br>    <span class="hljs-attr">&quot;installationFree&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span> <span class="hljs-comment">//标识当前Module是否支持免安装特性。- true：表示支持免安装特性，且符合免安装约束。- false：表示不支持免安装特性。</span><br><br>    <span class="hljs-attr">&quot;pages&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;$profile:main_pages&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-comment">//对应的是main_pages.json文件，用于配置ability中用到的page信息。</span><br><br><br>    <span class="hljs-attr">&quot;abilities&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-comment">//是一个数组，存放当前模块中所有的ability元能力的配置信息，其中可以有多个ability。</span><br><br>      <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;EntryAbility&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">//该标签标识当前ability的逻辑名，该名称在整个应用要唯一，标签值采用字符串表示（最大长度127个字节）。</span><br>        <span class="hljs-attr">&quot;srcEntry&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;./ets/entryability/EntryAbility.ts&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">//ability的入口代码路径。</span><br><br>        <span class="hljs-attr">&quot;description&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;$string:EntryAbility_desc&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-comment">//ability的描述信息。</span><br>        <br>        <span class="hljs-attr">&quot;icon&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;$media:icon&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-comment">//ability的图标。该标签标识ability图标，标签值为资源文件的索引。该标签可缺省，缺省值为空。如果ability被配置为MainElement，该标签必须配置。</span><br><br>        <span class="hljs-attr">&quot;label&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;$string:EntryAbility_label&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-comment">//ability的标签名。</span><br><br>        <span class="hljs-attr">&quot;startWindowIcon&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;$media:icon&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-comment">//启动页面的图标。</span><br><br>        <span class="hljs-attr">&quot;startWindowBackground&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;$color:start_window_background&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-comment">//启动页面的背景色。</span><br><br>        <span class="hljs-attr">&quot;exported&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;skills&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-comment">//标识能够接收的意图的action值的集合，取值通常为系统预定义的action值，也允许自定义。</span><br><br>          <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;entities&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-comment">//标识能够接收的Want的Action值的集合，取值通常为系统预定义的action值，也允许自定义。</span><br>              <span class="hljs-string">&quot;entity.system.home&quot;</span><br>            <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;actions&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-comment">//标识能够接收Want的Entity值的集合。</span><br>              <span class="hljs-string">&quot;action.system.home&quot;</span><br>            <span class="hljs-punctuation">]</span><br>          <span class="hljs-punctuation">&#125;</span><br>        <span class="hljs-punctuation">]</span><br>      <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">]</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="main-pages-json"><a href="#main-pages-json" class="headerlink" title="main_pages.json"></a>main_pages.json</h3><p>src&#x2F;main&#x2F;resources&#x2F;base&#x2F;profile&#x2F;main_pages.json文件保存的是页面page的路径配置信息，所有需要进行路由跳转的page页面都要在这里进行配置。</p><p><img src="/harmonyos/%E5%88%9D%E8%AF%86HarmonyOS%E2%80%94%E2%80%94%E8%AE%A4%E8%AF%86DevEco%20Studio%20&%20HarmonyOS%E5%B7%A5%E7%A8%8B%E7%BB%93%E6%9E%84/Image%20%5B14%5D.png" alt="HarmonyOS"></p>]]></content>
    
    
    <categories>
      
      <category>HarmonyOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HarmonyOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>初识HarmonyOS——构建你的第一个HarmonyOS应用</title>
    <link href="/harmonyos/%E5%88%9D%E8%AF%86HarmonyOS%E2%80%94%E2%80%94%E6%9E%84%E5%BB%BA%E4%BD%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AAHarmonyOS%20%E5%BA%94%E7%94%A8/"/>
    <url>/harmonyos/%E5%88%9D%E8%AF%86HarmonyOS%E2%80%94%E2%80%94%E6%9E%84%E5%BB%BA%E4%BD%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AAHarmonyOS%20%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="安装DevEco-Studio"><a href="#安装DevEco-Studio" class="headerlink" title="安装DevEco Studio"></a>安装DevEco Studio</h2><p>在HarmonyOS应用开发学习之前，需要进行一些准备工作，首先需要完成开发工具DevEco Studio的下载与安装以及环境配置。</p><p>进入<a href="https://developer.harmonyos.com/cn/develop/deveco-studio">DevEco Studio官网</a>下载，单击“立即下载”进入下载页面。<br><img src="/harmonyos/%E5%88%9D%E8%AF%86HarmonyOS%E2%80%94%E2%80%94%E6%9E%84%E5%BB%BA%E4%BD%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AAHarmonyOS%20%E5%BA%94%E7%94%A8/../%E5%88%9D%E8%AF%86HarmonyOS%E2%80%94%E2%80%94%E6%9E%84%E5%BB%BA%E4%BD%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AAHarmonyOS%20%E5%BA%94%E7%94%A8/Image.png" alt="HarmonyOS"></p><p>DevEco Studio提供了Windows版本和Mac版本选择，可以根据操作系统选择对应的版本进行下载。</p><p><a href="https://developer.huawei.com/consumer/cn/training/course/slightMooc/C101682488597649338">Windows安装教程</a>见官网教程</p><p>这里以 Mac 为例进行安装<br>我们下载完成后将压缩包解压后会看到一个 <code>deveco-studio-xxxxx.dmg</code> 文件，双击打开文件，我们会看到下面的对话框，按照提示将左边的<code>DevEco Studio</code>图标拖拽到右边的<code>Applications</code>文件夹<br><img src="/harmonyos/%E5%88%9D%E8%AF%86HarmonyOS%E2%80%94%E2%80%94%E6%9E%84%E5%BB%BA%E4%BD%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AAHarmonyOS%20%E5%BA%94%E7%94%A8/../%E5%88%9D%E8%AF%86HarmonyOS%E2%80%94%E2%80%94%E6%9E%84%E5%BB%BA%E4%BD%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AAHarmonyOS%20%E5%BA%94%E7%94%A8/Image%20%5B1%5D.png" alt="HarmonyOS"><br>等待拖拽完成我们就安装完成了。可以在启动台找到 DevEco Studio，双击运行启动。<br><img src="/harmonyos/%E5%88%9D%E8%AF%86HarmonyOS%E2%80%94%E2%80%94%E6%9E%84%E5%BB%BA%E4%BD%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AAHarmonyOS%20%E5%BA%94%E7%94%A8/../%E5%88%9D%E8%AF%86HarmonyOS%E2%80%94%E2%80%94%E6%9E%84%E5%BB%BA%E4%BD%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AAHarmonyOS%20%E5%BA%94%E7%94%A8/Image%20%5B2%5D.png" alt="HarmonyOS"></p><h2 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h2><p>安装完成后，首次启动IDE会进入配置向导。<br><img src="/harmonyos/%E5%88%9D%E8%AF%86HarmonyOS%E2%80%94%E2%80%94%E6%9E%84%E5%BB%BA%E4%BD%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AAHarmonyOS%20%E5%BA%94%E7%94%A8/../%E5%88%9D%E8%AF%86HarmonyOS%E2%80%94%E2%80%94%E6%9E%84%E5%BB%BA%E4%BD%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AAHarmonyOS%20%E5%BA%94%E7%94%A8/Image%20%5B3%5D.png" alt="HarmonyOS"><br>选择Agree，同意相应的条款<br><img src="/harmonyos/%E5%88%9D%E8%AF%86HarmonyOS%E2%80%94%E2%80%94%E6%9E%84%E5%BB%BA%E4%BD%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AAHarmonyOS%20%E5%BA%94%E7%94%A8/../%E5%88%9D%E8%AF%86HarmonyOS%E2%80%94%E2%80%94%E6%9E%84%E5%BB%BA%E4%BD%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AAHarmonyOS%20%E5%BA%94%E7%94%A8/Image%20%5B4%5D.png" alt="HarmonyOS"><br>点击OK，不导入已有配置，进入配置页。注意这里默认是local 我们选择install来安装<br><img src="/harmonyos/%E5%88%9D%E8%AF%86HarmonyOS%E2%80%94%E2%80%94%E6%9E%84%E5%BB%BA%E4%BD%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AAHarmonyOS%20%E5%BA%94%E7%94%A8/../%E5%88%9D%E8%AF%86HarmonyOS%E2%80%94%E2%80%94%E6%9E%84%E5%BB%BA%E4%BD%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AAHarmonyOS%20%E5%BA%94%E7%94%A8/Image%20%5B5%5D.png" alt="HarmonyOS"><br>然后一直选择 Next，进入下面页面<br><img src="/harmonyos/%E5%88%9D%E8%AF%86HarmonyOS%E2%80%94%E2%80%94%E6%9E%84%E5%BB%BA%E4%BD%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AAHarmonyOS%20%E5%BA%94%E7%94%A8/../%E5%88%9D%E8%AF%86HarmonyOS%E2%80%94%E2%80%94%E6%9E%84%E5%BB%BA%E4%BD%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AAHarmonyOS%20%E5%BA%94%E7%94%A8/Image%20%5B6%5D.png" alt="HarmonyOS"><br>我们选择 Accept， 然后再继续 Next 安装。<br><img src="/harmonyos/%E5%88%9D%E8%AF%86HarmonyOS%E2%80%94%E2%80%94%E6%9E%84%E5%BB%BA%E4%BD%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AAHarmonyOS%20%E5%BA%94%E7%94%A8/../%E5%88%9D%E8%AF%86HarmonyOS%E2%80%94%E2%80%94%E6%9E%84%E5%BB%BA%E4%BD%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AAHarmonyOS%20%E5%BA%94%E7%94%A8/Image%20%5B7%5D.png" alt="HarmonyOS"><br>等待配置自动下载完成，完成后，点击 <code>Finish</code>, IDE会进入欢迎页，我们也就成功配置好了开发环境。<br><img src="/harmonyos/%E5%88%9D%E8%AF%86HarmonyOS%E2%80%94%E2%80%94%E6%9E%84%E5%BB%BA%E4%BD%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AAHarmonyOS%20%E5%BA%94%E7%94%A8/../%E5%88%9D%E8%AF%86HarmonyOS%E2%80%94%E2%80%94%E6%9E%84%E5%BB%BA%E4%BD%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AAHarmonyOS%20%E5%BA%94%E7%94%A8/Image%20%5B8%5D.png" alt="HarmonyOS"></p><h2 id="创建-HarmonyOS-项目"><a href="#创建-HarmonyOS-项目" class="headerlink" title="创建 HarmonyOS 项目"></a>创建 HarmonyOS 项目</h2><p>我们配置好环境后，打开DevEco Studio，那么首先会进入欢迎页。<br><img src="/harmonyos/%E5%88%9D%E8%AF%86HarmonyOS%E2%80%94%E2%80%94%E6%9E%84%E5%BB%BA%E4%BD%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AAHarmonyOS%20%E5%BA%94%E7%94%A8/../%E5%88%9D%E8%AF%86HarmonyOS%E2%80%94%E2%80%94%E6%9E%84%E5%BB%BA%E4%BD%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AAHarmonyOS%20%E5%BA%94%E7%94%A8/Image%20%5B19%5D.png" alt="HarmonyOS"><br>在欢迎页中单击Create Project，进入项目创建页面。<br><img src="/harmonyos/%E5%88%9D%E8%AF%86HarmonyOS%E2%80%94%E2%80%94%E6%9E%84%E5%BB%BA%E4%BD%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AAHarmonyOS%20%E5%BA%94%E7%94%A8/../%E5%88%9D%E8%AF%86HarmonyOS%E2%80%94%E2%80%94%E6%9E%84%E5%BB%BA%E4%BD%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AAHarmonyOS%20%E5%BA%94%E7%94%A8/Image%20%5B10%5D.png" alt="HarmonyOS"><br>选择 <code>Application</code>，然后选择 <code>Empty Ability</code>，单击 Next 进入工程配置页。<br><img src="/harmonyos/%E5%88%9D%E8%AF%86HarmonyOS%E2%80%94%E2%80%94%E6%9E%84%E5%BB%BA%E4%BD%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AAHarmonyOS%20%E5%BA%94%E7%94%A8/../%E5%88%9D%E8%AF%86HarmonyOS%E2%80%94%E2%80%94%E6%9E%84%E5%BB%BA%E4%BD%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AAHarmonyOS%20%E5%BA%94%E7%94%A8/Image%20%5B11%5D.png" alt="HarmonyOS"><br>配置页中，详细信息如下：</p><ul><li><strong>Project name</strong>是开发者可以自行设置的项目名称，这里根据自己选择修改为自己项目名称。</li><li><strong>Bundle name</strong>是包名称，默认情况下应用ID也会使用该名称，应用发布时对应的ID需要保持一致。</li><li><strong>Save location</strong>为工程保存路径，建议用户自行设置相应位置。</li><li><strong>Compile SDK</strong>是编译的API版本，这里默认选择API9。</li><li><strong>Model</strong>选择Stage模型，其他保持默认即可。</li></ul><p>然后单击 <code>Finish</code> 完成工程创建，等待工程同步完成。</p><h3 id="运行Hello-World"><a href="#运行Hello-World" class="headerlink" title="运行Hello World"></a>运行Hello World</h3><p>IDE 为我们提供了本地模拟器供开发者使用，我们首先需要下载安装本地模拟器，然后进行运行工程。</p><ol><li>单击顶部工具栏 <font color="red">Tools&gt;Device Manager</font>。<br><img src="/harmonyos/%E5%88%9D%E8%AF%86HarmonyOS%E2%80%94%E2%80%94%E6%9E%84%E5%BB%BA%E4%BD%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AAHarmonyOS%20%E5%BA%94%E7%94%A8/../%E5%88%9D%E8%AF%86HarmonyOS%E2%80%94%E2%80%94%E6%9E%84%E5%BB%BA%E4%BD%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AAHarmonyOS%20%E5%BA%94%E7%94%A8/Image%20%5B12%5D.png" alt="HarmonyOS"></li><li>启动模拟器<ul><li>如果已经创建过模拟器了，则可以直接点击 <code>Actions</code> 按钮启动模拟器。</li></ul></li></ol><ul><li>如果没有创建：则选择 <code>Local Emulator</code>，设置合适的 <code>Local Emulator Location</code> 存储地址，然后单击 <code>+New Emulator</code>。<br><img src="/harmonyos/%E5%88%9D%E8%AF%86HarmonyOS%E2%80%94%E2%80%94%E6%9E%84%E5%BB%BA%E4%BD%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AAHarmonyOS%20%E5%BA%94%E7%94%A8/../%E5%88%9D%E8%AF%86HarmonyOS%E2%80%94%E2%80%94%E6%9E%84%E5%BB%BA%E4%BD%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AAHarmonyOS%20%E5%BA%94%E7%94%A8/Image%20%5B13%5D.png" alt="HarmonyOS"><br>选择 <code>Huawei_Phone</code> 手机模拟器，单击 <code>Next</code>，进入模拟器系统下载页。<br><img src="/harmonyos/%E5%88%9D%E8%AF%86HarmonyOS%E2%80%94%E2%80%94%E6%9E%84%E5%BB%BA%E4%BD%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AAHarmonyOS%20%E5%BA%94%E7%94%A8/../%E5%88%9D%E8%AF%86HarmonyOS%E2%80%94%E2%80%94%E6%9E%84%E5%BB%BA%E4%BD%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AAHarmonyOS%20%E5%BA%94%E7%94%A8/Image%20%5B14%5D.png" alt="HarmonyOS"></li></ul><p>选择下载 <code>api9</code> 的系统镜像，然后单击 <code>Next</code>，等待下载完成。</p><p><img src="/harmonyos/%E5%88%9D%E8%AF%86HarmonyOS%E2%80%94%E2%80%94%E6%9E%84%E5%BB%BA%E4%BD%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AAHarmonyOS%20%E5%BA%94%E7%94%A8/../%E5%88%9D%E8%AF%86HarmonyOS%E2%80%94%E2%80%94%E6%9E%84%E5%BB%BA%E4%BD%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AAHarmonyOS%20%E5%BA%94%E7%94%A8/Image%20%5B5%5D.png" alt="HarmonyOS"></p><p>下载完成后，进行创建相应的手机模拟器，单击 <code>Finish</code> 完成创建。<br><img src="/harmonyos/%E5%88%9D%E8%AF%86HarmonyOS%E2%80%94%E2%80%94%E6%9E%84%E5%BB%BA%E4%BD%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AAHarmonyOS%20%E5%BA%94%E7%94%A8/../%E5%88%9D%E8%AF%86HarmonyOS%E2%80%94%E2%80%94%E6%9E%84%E5%BB%BA%E4%BD%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AAHarmonyOS%20%E5%BA%94%E7%94%A8/Image%20%5B16%5D.png" alt="HarmonyOS"><br>下载完成后，在 <code>Local Emulator</code> 页面中会出现创建的手机模拟器，点击 <code>Actions</code> 按钮，就能够启动模拟器。<br><img src="/harmonyos/%E5%88%9D%E8%AF%86HarmonyOS%E2%80%94%E2%80%94%E6%9E%84%E5%BB%BA%E4%BD%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AAHarmonyOS%20%E5%BA%94%E7%94%A8/../%E5%88%9D%E8%AF%86HarmonyOS%E2%80%94%E2%80%94%E6%9E%84%E5%BB%BA%E4%BD%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AAHarmonyOS%20%E5%BA%94%E7%94%A8/Image%20%5B17%5D.png" alt="HarmonyOS"><br>模拟器启动后我们就可以看到一个华为手机<br><img src="/harmonyos/%E5%88%9D%E8%AF%86HarmonyOS%E2%80%94%E2%80%94%E6%9E%84%E5%BB%BA%E4%BD%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AAHarmonyOS%20%E5%BA%94%E7%94%A8/../%E5%88%9D%E8%AF%86HarmonyOS%E2%80%94%E2%80%94%E6%9E%84%E5%BB%BA%E4%BD%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AAHarmonyOS%20%E5%BA%94%E7%94%A8/Image%20%5B18%5D.png" alt="HarmonyOS"><br>同时，IDE 顶部也会也会显示已连接模拟器，我们点击 IDE 右上角的 <code>Run</code> 按钮就可以将 Hello World 运行在模拟器上。<br><img src="/harmonyos/%E5%88%9D%E8%AF%86HarmonyOS%E2%80%94%E2%80%94%E6%9E%84%E5%BB%BA%E4%BD%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AAHarmonyOS%20%E5%BA%94%E7%94%A8/../%E5%88%9D%E8%AF%86HarmonyOS%E2%80%94%E2%80%94%E6%9E%84%E5%BB%BA%E4%BD%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AAHarmonyOS%20%E5%BA%94%E7%94%A8/Image%20%5B19%5D.png" alt="HarmonyOS"><br><img src="/harmonyos/%E5%88%9D%E8%AF%86HarmonyOS%E2%80%94%E2%80%94%E6%9E%84%E5%BB%BA%E4%BD%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AAHarmonyOS%20%E5%BA%94%E7%94%A8/../%E5%88%9D%E8%AF%86HarmonyOS%E2%80%94%E2%80%94%E6%9E%84%E5%BB%BA%E4%BD%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AAHarmonyOS%20%E5%BA%94%E7%94%A8/Image%20%5B20%5D.png" alt="HarmonyOS"></p><p>至此我们就成功的将一个HarmonyOS 应用部署在模拟器上。 下一节我们将介绍DevEco Studio 和 工程目录结构。</p>]]></content>
    
    
    <categories>
      
      <category>HarmonyOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HarmonyOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
